# 11주차. 코드 보안: 코드 속에 뒷길을 만드는 기술

# 시스템과 프로그램

## 보안에 취약한 소스코드

- 소스코드에서 문제가 생기는 요인은 데이터의 형태와 길이에 대한 불명확한 정의
- 소스코드가 어셈블리어에게 하드웨어를 주며 명령을 내렸는데 데이터의 형태와 길이에 대한 불명확한 정의로 해커에게 공격을 받는 것

## 시스템 메모리의 구조

- 프로그램을 동작시키면 프로그램이 동작하기 위한 가상의 공간이 메모리에 생성됨
- 이 공간은 목적에 따라 상위 메모리와 하위 메모리로 나뉘는데 상위 메모리에는 스택, 하위 메모리에는 힙(사용자가 컨트롤 가능) 생성

#### 스택

- 프로그램 로직이 동작하기 위한 인자와 프로세스 상태를 저장하는 데 사용.
- 레지스터의 임시 저장, 서브루틴 사용 시 복귀 주소 저장, 서브루틴에 인자 전달 등에 사용.
- 스택은 메모리의 상위 주소에서 하위 주소 방향으로 사용하며, 후입선출 원칙에 따라 나중에 저장된 값을 먼저 사용

#### 힙

- 프로그램이 동작할 때 필요한 데이터 정보를 임시로 저장하는 데 사용
- 프로그램이 실행될 때까지 알 수 없는 가변적인 양의 데이터를 저장하기 위해 프로그램 프로세스가 사용할 수 있도록 미리 예약된 메인 메모리 영역
- 힙 영역은 프로그램에 의해 할당되었다가 회수되는 작용을 되풀이함
- 힙의 기억 장소는 포인터 변수를 통해 동적으로 할당받고 돌려주며, 연결 목록이나 나무, 그래프 등의 동적인 데이터 구조를 만드는 데 반드시 필요함.
- 프로그램 실행 중에 해당 힙 영역이 없어지면 메모리 부족으로 이상 종료됨.

#### 레지스터

- CPU의 임시 메모리로 CPU 연산과 어셈블리어의 동작에 필요
- 주로 사용되는 인텔 80x86 CPU가 프로그램 동작을 위해 제공하는 레지스터의 종류

## 프로그램 실행 구조

- 스택과 레지스터의 실제 사용의 예

  - main 함수와 덧셈 하는 서브루틴 함수가 있는 프로그램

    ```c
    void main() {
      int c;
      c = function(1, 2);
    }

    int function(int a, int b) {
      char buffer[10];
      a = a + b;
      return a;
    }
    ```

  - 어셈블리어로 된 코드 생성
  - 과정
    - pushl %ebp
      - main 함수가 시작되면 EBP(extended base pointer) 레지스터 값을 스택에 저장
      - EBP 레지스터에는 스택에서 현재 호출되어 사용되는 함수의 시작 주소 값이 저장되며 함수 실행과 관련된 지역변수 참조의 기준이 됨.
      - 스택에 저장된 EBP는 SFP라고 부름.
      - EBP 바로 앞에는 함수 종료 시 점프할 주소 값이 저장되는 RET(Return Address) 저장
    - movl %esb, %ebp
      - ESP(extended stack pointer) 레지스터는 항상 현재 스택 영역의 가장 하위 주소 저장.
      - 스택은 높은 주소에서 낮은 주소로 이동하고 데이터를 저장하므로 스택이 확장되면 스택 포인터도 높은 주소에서 낮은 주소로 변경됨.
      - 해당 명령은 현재 SP 값을 EBP 레지스터에 저장하라는 것
    - subl \$4,%esp
      - ESP 값에서 4바이트만큼을 뺀다. 즉 스택에 4바이트 용량을 할당하낟
    - pushl \$2
      - 스택에 정수 2 저장
    - pushl \$1
      - 스택에 정수 1 저장
    - call function
      - 함수 호출
    - pushl %ebp
      - function 함수의 기준 값으로, 현재 EBP 값을 스택에 저장
    - movl %esp, %ebp
      - `function(1,2)` 시작에서도 프롤로그가 실행.
    - subl \$12, %esp
      - ESP 값(`char buffer[10]`)에서 12 바이트를 뺌 (스택에 12바이트 용량 할당)
      - 소스코드에서 `char buffer[10]`과 같이 10바이트만큼 할당되도록 했으나 스택에서는 4바이트 단위로 할당되므로 12바이트가 할당됨
    - movl 12(%ebp), %eax
      - EBP에 12바이트를 더한 주소 값 내용을 EAX(extended accumulator) 값에 복사, 누산기인 EAX 레지스터는 입출력과 대부분 산술 연산에 사용됨.
    - addl %eax, 8(%ebp)
      - EBP에 8바이트를 더한 주소 값 내용에 EAX 값을 더하므로 8(%ebp) 값은 3이 됨.
    - movl 8(%ebp), %edx
      - EDX(extended data) 레지스터는 입출력 연산에 사용하는 것으로, 큰 수의 곱셈과 나눗셈 연산 시 EAX와 함께 사용.
      - movl 8(%ebp), %dex 명령은 EBP에 8바이트를 더한 주소 값 내용(정수 3)을 EDX에 저장하는 것으로 a = a + b의 결과값을 저장하는 과정.
    - jmp .L2
      - L2로 점프
    - leave
      - 함수 끝냄
    - ret
      - function 함수 마치고 함수에 저장된 EBP 값 제거 뒤 main 함수의 원래 EBP 값으로 EBP 레지스터 값 변경.
    - addl \$8, %esp
      - ESP에 8바이트 더함
    - movl %eax, %eax
      - EAX 값을 EAX로 복사 (의미 없음)
    - movl %eax, -4(%ebp)
      - EBP에서 4 바이트를 뺀 주소 값(int c)에 EAX 값 복사
    - leave
    - ret
      - 모든 과정 마치고 프로그램 종료

## 셸

- 운영체제를 둘러싼 채 입력받는 명령어를 실행하는 명령어 해석기
- 역할
  - 자체에 내장된 명령어 제공
  - 입출력 오류에 대한 리다이렉션 기능 제공
  - 와일드카드 기능 제공
  - 파이프라인 기능 제공
  - 조건부, 무조건부 명령열 작성 기능 제공
  - 서브셸 생성 기능 제공
  - 후면 처리 가능
  - 셸스크립트 작성 가능
- `/bin/sh`를 실행한 결과와 shell을 컴파일한 실행 코드를 실행한 결과가 거의 같다
- 버퍼 오버플로나 포맷 스트링 공격에서도 셸을 기계어화한 코드로 관리자 권한의 셸을 획득함.

## 프로세스 권한과 SetUID

- SetUID는 유닉스 시스템을 해킹하는 데 매우 중요한 요소로, 유닉스 파일에 rwsr-xr-x로 권한이 설정되어 있는 경우
- SetUID 파일은 누가 실행하든 상관 없이 해당 파일이 실행될 때 파일 소유자 권한을 갖는 것이 특징

#### SetUID 이용한 간단한 해킹

- shell 파일에 SetUID 부여.
- 일반 사용자 권한에서 shell 파일 실행
- id 명령으로 자신이 uid 500의 wishfree라는 일반 계정을 확인, 하지만 SetUID 권한이 부여된 shell을 실행하면 euidEffective Uid가 0번, 즉 root로 바뀌고 프롬프트 관리자 권한을 의미하는 #로 바뀜.

## 버퍼오버플로 공격

- 기본적인 버퍼 오버플로 공격은 데이터의 길이에 대한 불명확한 정의를 악용한 덮어쓰기로 발생
- 경계선 관리가 적절하게 수행되어 덮어쓸 수 없는 부분에 해커가 임의의 코드를 덮어쓰는 것을 의미.
- 버퍼 오버플로에 취약한 함수와 그렇지 않은 함수가 있음. 프로그래머가 취약한 특정 함수를 쓰지 않는다면 공격 어려워짐.

#### 버퍼오버플로 공격 원리

- 예제 코드
  ```c
  int main(int argc, char *argv[]) {
    char buffer[10];
    strcpy(buffer, argv[1]);
    printf("%s\n", &buffer);
  }
  ```
  - `int main(int argc, char *argv[])`
    - argc는 취약한 코드인 bugfile.c가 컴파일 되어 실행되는 프로그램의 인수 개수. \*argv[]는 포인터 배열로서의 인자로 입력되는 값의 번지수를 차례로 저장함.
  - `char buffer[10]`
    - 10바이트 크기의 버퍼 할당.
  - `strcpy(buffer, argv[1])`
    - 버퍼에 첫 번째 인자(argv[1])를 복사. 즉 abcd 값을 버퍼에 저장.
  - `printf("%s\n", &buffer);`
    - 버퍼에 저장된 내용 출력
- 실제 버퍼 오버플로 공격은 `strcpy(buffer, argv[1])`에서 일어남.
- GDB를 이용하여 main 함수를 살펴본 다음 strcpy가 호출되는 과정을 살펴보면
  - 0x80483f8 `<main>`
    - push %ebp
  - 0x80483f9 `<main+1>`
    - mov %esp, %ebp
    - 스택에 EBP 값을 밀어넣고 현재의 ESP 값을 EBP 레지스터에 저장.
  - 0x80483fb `<main+3>`
    - sub \$0xc, %esp
    - main함수의 char buffer[10]을 실행하는 과정
    - char 명령으로 실제 메모리에 10 바이트를 할당했으나 메모리에서는 모두 4바이트 단위로 할당되어 실제 할당되는 메모리는 12바이트임.
  - 0x80483fe `<main+6>`
    - mov 0xc(%eb), %eax
    - EBP에서 상위 12바이트(0xC) 내용을 EAX 레지스터에 저장하면 EAX 레지스터는 RET보다 상위 주소의 값을 읽어들임.
    - char \*argv[]를 가리키고 EAX에 argv[]에 대한 포인터 값이 저장됨.
  - 0x8048401 `<main+9>`
    - add \$0x4, %eax
    - EAX 값을 4바이트 만큼 증가. argv[]에 대한 포인터이므로 argv[1]을 가리킴.
  - 0x8048404 `<main+12>`
    - mov (%eax), %edx
    - EAX 레지스터가 가리키는 주소 값을 EDX 레지스터에 저장. 프로그램 실행할 때 인수 부분을 가리킴.
  - 0x8048406 `<main+14>`
    - push %edx
    - 프로그램을 실행할 때 인수에 대한 포인터를 스택에 저장. 인수를 넣지 않고 프로그램을 실행하면 0x0의 값이 스택에 저장됨.
  - 0x8048407 `<main+15>`
    - lea 0xfffffff4(%ebp),%eax
    - EAX 레지스터에 12(%ebp) 주소 값 저장.
  - 0x804840a `<main+18>`
    - push %eax
    - 스택에 EAX 레지스터 값을 저장
    - lea(load effective address): 왼쪽 피연산자의 주소(메모리)를 오른쪽 피연산자(레지스터)로 전송함. 보통 C언어에서 포인터 변수를 설정하는데 사용
  - 0x804840b `<main+19>`
    - call 0x8048340 `<strcpy>`
    - 4 ~ 9에서 strcpy(buffer, argv[1])을 실행하기 위해 buffer와 argv[1]과 관련된 사항을 스택에 모두 상주시키고 마지막으로 strcpy명령 호출.
  - strcpy 함수는 입력된 인수의 경계를 체크하지 않으므로 10바이트 길이를 넘지 않아야만 그보다 큰 인수를 받아도 스택에 쓰인다.
  - 13개 A를 인수로 사용하면 A가 쌓일 것.
  - 입력 버퍼 이상 문자열 입력 시 세그멘테이션 오류 발생
  - 예를 들어 16자리 문자 입력 시 bugfile.c의 char buffer[10]이 할당되는 주소 공간이 12바이트, EBP가 저장되는 공간이 4바이트므로 A가 16개, 즉 16바이트(주소공간 12바이트, EBP 저장공간 4바이트)를 덮어씌우고 스택의 RET 값을 침범하면서 오류가 생긴 것.
  - 공격 실행. 일반적 공격에는 egg shell 이용
  - 메모리의 0xbfffb58에 셀 적재
  - 일반 사용자 권한으로 돌아가서 perl을 이용하여 A 문자열과 셸의 메모리 주소를 bugfile에 직접 실행
  - 공격 종료. 계정이 root로 바뀐 것을 확인할 수 있음.
- 대응책
  - 버퍼오버플로 취약한 함수 사용하지 않기
  - 최신 OS 사용

## 포맷스트링 공격 개념

- 데이터의 형태의 대한 불명확한 정의 때문에 발생하는 문제
- 취약한 포맷 스트링
  ```c
  #include <stdio.h>
  main() {
    char *buffer = "wishfree\n";
    printf(buffer);
  }
  ```
- 문자를 이용한 메모리 변조
  - 포맷 스트링 이용하며 메모리의 내용 변조도 가능한 상황
