# 기말고사 정리

# 대칭 암호

# 문자 암호에서 비트열 암호로

## 부호화

- 암호화에 컴퓨터 사용이 필수
- 암호화 프로그램도 평문을 비트열로 변경하고 비트열로 된 암호문을 출력
- 부호화(Encoding): 문자열을 비트열로 바꾸는 것

#### ASCII

문자열 midnight을 비트열로 부호화

```
m -> 01101101
i -> 01101001
...
```

## XOR

- 익스클루시브 오아 또는 짧게 엑스오아라고 읽는다
- 배타적 논리합
- XOR은 +와 O를 합친 기호를 써서 표현
- 같은 숫자끼리의 XOR은 반드시 0이 된다

```
0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0
```

#### 비트열 XOR

```
01001100 ... A
10101010 ... B

두 비트열 XOR

11100110 ... A XOR B
```

```
11100110 ... A XOR B
10101010 ... B

두 비트열 XOR

01001100 ... A XOR B XOR B = A
```

#### 암호화/복호화의 순서와 매우 비슷

- 평문 A를 키 B로 암호화하고 암호문 A XOR B를 얻는다
- 암호문 A XOR B를 키 B로 복호화해서 평문 A를 얻는다
- XOR은 그림을 마스크 한다

# 일회용 패드 - 절대 해독 불가능한 암호

## 일회용 패드란

전사공격에서 키공간을 모두 탐색하더라도 해독할 수 없는 암호

## 일회용 패드의 암호화

평문과 랜덤한 비트열과의 XOR만을 취하는 단순한 암호

#### 예시

```
평문: midnight (ASCII로 부호화)
키: 랜덤 비트열

1. 평문과 키를 XOR
```

## 일회용 패드의 복호화

암호문과 키의 XOR을 계산하면 평문이 된다

## 일회용 패드는 해독할 수 없다

- 현실적인 시간 내 해독이 곤란하다는 의미는 아니다
- 키 공간 전체를 순식간에 계산할 수 있는 무한대의 계산력을 갖는 컴퓨터로도 일회용 패드는 해독할 수 없다
- 문자열이 복호화 되었다 하더라도 그것이 바른 평문인지 아닌지 판정할 수 없다

#### 전사공격

- 암호문을 복호화 해보면 도중에 모든 64비트 패턴이 등장한다
- 따라서 어느 것이 바른 평문인지 알 수 없다. 즉 어떤 키를 사용하면 바르게 복호화할 수 있는지 알 수 없다

## 일회용 패드는 왜 사용되지 않은 것일까

- 키 배송
  - 키 길이가 통신문의 길이와 같다
  - 키를 안전하게 보낼 수 있는 방법이 있다면 평문 그 자체를 같은 방법으로 안전하게 보낼 수 없다
- 키 보존
  - 평문과 같은 비트 길이의 키를 안전하게 보존할 수 있다면 평문 그 자체를 안전하게 보존해 둘 수 있다
- 키 재이용
  - 과거에 사용한 랜덤한 비트열은 절대 재이용해서는 안된다
- 키 동기화
  - 통신하는 동안 송수신자 사이에 키가 되는 비트열이 1비트라도 어긋나서는 안 된다
- 키 생성
  - 난수를 대량으로 생성할 필요가 있다
  - 난수는 의사 난수(프로그램을 이용해서 생성하는 난수)가 아니라 실제 난수여야 한다

# DES

- DES는 1977년에 미국의 연방 정보처리 표준 규격으로 채택된 대칭 암호
- 전사공격으로 해독할 수 있는 수준

## 암호화/복호화

- 64비트 평문을 64비트 암호문으로 암호화하는 대칭 암호 알고리즘
- 키의 비트 길이는 56비트
- 64비트 평문을 하나의 단위로 모아서 암호화

#### 블록 암호

- 블록 단위로 처리를 하는 암호 알고리즘
- 긴 비트 길이의 평문을 암호화 위해 평문을 64비트 블록으로 나누고 각각 DES로 암호화 한다

#### DES 구조

- 페이스텔 네트워크
  - 페이스텔 구조
  - 페이스텔 암호
  - DES 외의 다른 블록암호로도 채용
  - 어려 개의 라운드로 구성
  - DES는 16라운드로 구성

#### 페이스텔 네트워크 라운드

1. 입력을 L과 R로 나눈다
2. R을 그대로 R로 보낸다
3. R을 라운드 함수 F로 보낸다
4. 라운드 함수 F는 R과 서브 키 K1을 입력으로 사용하여 랜덤하게 보이는 비트열을 계산한다
5. 얻어진 비트열과 L을 XOR 한다
6. 그 결과를 다음 라운드의 L로 사용한다
7. 마지막 라운드는 L과 R을 교환하지 않는다

#### 페이스텔 네트워크 복호화

같은 서브 키를 사용하여 1라운드를 더 통과시키면 원래대로 돌아간다

#### 페이스텔 네트워크 특징

- 원하는 만큼 라운드 수를 늘릴 수 있다
- 라운드 함수 F에 어떤 함수를 사용해도 복호화가 가능하다
- 암호화와 복호화를 완전히 동일한 구조로 실현할 수 있다

## 차분 해독법과 선형 해독법

- 차분 해독법
  - 블록암호 해독법
  - Biham과 Shamir가 개발
  - 평문의 일부를 변경할 때 암호문이 어떻게 변화하는지 관찰하여 조사하는 암호 해독법
- 선형 해독법
  - 마츠이가 개발
  - 평문과 암호문 비트를 몇 개 정도 XOR 해서 0이 되는 확률을 조사하는 암호 해독법

#### 차분/선형 해독법 전제 조건

- 공격자는 선택 평문 공격(CPA: Chosen Plaintext Attack)을 할 수 있다
- 즉, 암호 해독자가 임의로 만든 평문을 암호화 할 수 있어야 한다

#### AES와 차분/선형 해독법

차분 해독법이나 선형 해독법으로부터 안전하다

# 트리플 DES

## 트리플 DES란

- DES는 전사공격으로 현실적인 시간 내에 해독
- DES를 대신할 블록 암호가 필요
- 이를 위해 개발된 것이 트리플 DES
- DES보다 강력하도록 DES를 3단 겹치게 한 암호 알고리즘

## 트리플 DES 암호화

- 과정
  - 평문
  - 트리플 DES (DES-EDE3)
    - 키 K1로 암호화
    - 키 K2로 복호화
    - 키 K3로 암호화
  - 암호문
- DES로도 사용 가능

#### 트리플 DES 종류

- DES: 모든 키에 같은 비트열을 사용
- DES-EDE2
  - 키1과 키3에 같은 키를 사용하고 키2에 다른 키를 사용
  - EDE는 암호화 -> 복호화 -> 암호화 순서
- DES-EDE3: 키1, 키2, 키3 모두 다른 비트열을 사용

## 트리플 DES 복호화

- 암호화의 역순
- 키3, 키2, 키1의 순으로 복호화 -> 암호화 -> 복호화를 행함

## 트리플 DES의 현황

- 현재도 은행 등에서 사용
- 처리 속도는 빠르지 않고 안전성 면에서도 풀려버린 사례가 있다
- 우리나라에서는 3-DES를 표준으로 정하지 않음
- 우리나라 국가 표준은 SEED 및 ARIA

# AES 선정 과정

## AES란

- DES를 대신한 새로운 표준 대칭 암호 알고리즘
- AES의 후보로서 다수의 대칭 암호 알고리즘을 제안했지만 그 중 Rijndael이라는 대칭 암호 알고리즘이 2000년에 AES로서 선정

## AES 선정 과정

- NIST에서 공모
- 경쟁방식에 의한 표준화
- 조건
  - 제한 없이 무료로 이용
  - ANSI C와 Java에 의한 구현
  - 암호해독에 대한 강도의 평가
  - 암호 알고리즘 설계 규격과 프로그램 공개

## AES 최종 후보 및 선정

- 1차 심사 통과 15개: CAST256, Crypton, DEAL, DFC, E2, Frog, HPC, LOKI97, Magenta, MARS, RC6, Rijndael, SAFER+, Serpent, Twofish
- 2차 심사 통과: 5개
  - MARS - IBM
  - RC6 - RSA
  - Rijndael - Daemen, Rijmen
  - Serpent - Anderson, Biham, Knudsen
  - Twofish - Counterpane

# Rijndael

## Rijndael 이란

- 벨기에 연구자 Daemen과 Rijmen이 설계한 블록 암호 알고리즘
- 블록 길이: 128비트
- 키의 비트 길이
  - 128비트
  - 256비트
  - 32비트

## Rijndael의 암호화와 복호화

- 복수의 라운드로 구성 (10 ~ 14)
- SPN(Substitution-Permutation Network) 구조
- SubBytes (바이트 대체), InvSubBytes (역 바이트 대체, 복호화)
- ShiftRows (행 이동), InvShiftRows (역 행 이동, 복호화)
- MixColumns (열 섞기), InvMixColumns (역 열 섞기, 복호화)
- AddRoundKey (라운드 키와 XOR)

## Rijndael의 해독

- Rijndael의 수식을 수학적인 조작에 의해 풀 수 있다면 Rijndael을 수학적으로 해독할 수 있을 것
- Rijndael에 대한 유효한 공격은 현재로서는 발견되지 않았다

## 어떤 암호를 사용하면 좋은가

- DES: 사용하지 않는다, 과거 SW와 호환성 유지를 위해서만 필요
- 트리플 DES
  - 호환성 문제로 당분간 사용
  - 점차 AES로 대체
- SEED 및 ARIA: 우리나라 표준
- AES(Rijndael)
  - 고속
  - 다양한 플랫폼
  - 현재까지는 안전
  - 사용 권장
  - AES 최종 후보 5개도 사용 가능

# 퀴즈

## 문자를 수를 대응시키는 것과 시저 암호

시저 암호에서 사용되는 알파벳은 A부터 Z까지 26문자. 여기에서 A를 0, B를 1... 이렇게 대응시킬 때 시저 암호에서 3문자 앞으로 평행이동이라는 암호화는 어떻게 계산하는 것인가

> 키가 3인 시저암호는 3을 더한 후 26으로 나누고 그 나머지를 구한다
> 나머지를 구하는 것은 23, 24, 25에 대응하는 문자의 경우 처음 알파벳으로 대응 시키기 위함이다

## 일회용 패드와 압축

일회용 패드의 이야기를 들은 앨리스는 일회용 패드에서는 키의 길이와 같다고 하는데, 나는 데이터를 압축하는 프로그램을 가지고 있다. 이것을 사용하면 일회용 패드의 키를 압축해서 짧게 할 수 있지 않을까? 앨리스의 생각은 옳은가?

> 바르지 않다
> 일회용 패드의 키는 어떤 압축 소프트웨어를 써도 압축할 수 없기 때문. 일회용 키는 랜덤하기 때문에 반복 패턴을 갖고 있지 않다.

## 대칭 암호에서 필요한 키의 비트 길기

지금이 당신이 이용할 수 있는 컴퓨터 파워는

- 컴퓨터 1대는 10초 간 10의 20승 개의 키를 시험
- 컴퓨터는 10의 100승 대 존재
- 전체 컴퓨터를 10의 20승 년 움직인다

이정도 컴퓨터 사용 시 키 공간에 속하는 키 전부를 전사 공격으로 조사할 수 없도록 하기 위해 비트 길이는 몇 비트면 되는가?

1. 512비트
2. 1024비트
3. 4096비트
4. 1만비트
5. 100만 비트로도 부족하다

> 512비트
> 1년을 초로 환산 = 365 x 24 x 60 x 60 = 31,622,400 x 키의 총 수 x 컴퓨터 대수 x 컴퓨터 실행 시간
> 3.16224 x 10의 147승
> 2의 512승 = 1.340780 x 10의 154승

## 대칭 암호의 기초 지식

1. 대칭 암호에서는 암호화 키와 복호화 키는 같다 -> O
2. 장래 컴퓨터의 계산력이 충분히 높아지면 일회용 패드의 암호문을 현실적 시간 내에 해독할 수 있게 된다 -> X
3. 키의 길이가 56비트 일 때 전사 공격으로 바른 키가 발견되기까지 평균 시행 횟수는 약 2의 28승 회이다 -> X, 2의 55승
4. AES는 강한 대칭 암호 알고리즘이지만 상용으로 이용하기 위해 NIST에 대해 특허료를 지불해야 한다 -> X
5. AES로 선정된 암호 알고리즘은 Rijndael이다 -> O

---

# 공개키 암호

# 키 배송 문제

## 키 배송 문제

- 대칭 암호를 사용하려면 송신자와 수신자가 대칭키를 사전에 공유해야함
- 대칭 키를 보내지 않으면 수신자 밥은 복호화할 수 없다
- 키를 보내 버리면 도청자 이브도 복호화 가능
- 안전하게 키를 보내는 방법 고민 필요
  - 키의 사전 공유
    - 안전한 방법으로
    - 직접 전달 안전
    - 이메일, 우편 등은 위험
    - 인원 많으면 관리 키 수 증가
      - 사원 1000명의 사원 한 사람이 나머지 999명과 통신한다면 통신용 키 999개
      - 회사 전체 필요 키 수 = `1000 x 9 / 2 = 49만 9500개`
      - 현실적이지 못함
  - 키 배포 센터에 의한 해결
    - 암호 통신 마다 통신용 키를 키 배포 센터에 의뢰해 개인과 키 배포 센터 사이에서만 키를 사전에 공유
    - 키 배포 센터의 역할을 하는 컴퓨터를 지정
    - 구성원 전원의 키를 보존
    - 앨리스가 밥에게 암호 메일 보내기
      - 앨리스는 키 배포 센터에 밥과 통신하고 싶다고 신청
      - 키 배포 센터는 의사난수 생성기를 써서 세션 키(K)를 만든다. 이 것은 앨리스와 밥이 이번 통신만을 위한 일시적인 키
      - 키 배포 센터는 데이터베이스로부터 앨리스의 키(KA)와 밥의 키(KB)를 꺼낸다
      - 키 배포 센터는 앨리스의 키를 써서 세션 키를 암호화`(CA = EKA(K))`해서 앨리스에게 보낸다
      - 키 배포 센터는 밥의 키를 써서 세션 키를 암호화`(CB = EKB(K))`해서 밥에게 보낸다
      - 앨리스는 키 배포 센터로부터 온 세션 키(앨리스의 키로 암호화되어 있음)를 복호화`(K = DKA(CA))`해서 세션 키를 얻는다
      - 앨리스는 세션 키를 써서 밥에게 보낼 메일을 암호화`(C = EK(M))`해서 밥에게 보낸다
      - 밥의 키 배포 센터로부터 온 세션 키(밥의 키로 암호화 되어 있음)를 복호화`(K = DKB(CB))`해서 세션 키를 얻는다
      - 밥은 세션 키를 써서 앨리스에게 온 암호문을 복호화`(M = DK(C))`한다
      - 앨리스와 밥은 세션 키를 삭제한다
    - 문제점
      - 구성원 수 증가 시 키 배포 센터의 부하
      - 키 배포 센터의 컴퓨터 고장 시 조직 전체 암호 통신 마비
      - 키 배포 센터가 공격의 대상이 될 수 있음
      - 이 시스템이 잘 작동되려면 앨리스와 밥이 키 배포 센터를 신뢰해야
  - 디피-헬만 키 교환
    - 암호 통신을 원하는 두 사람이 있다면 어떤 정보를 교환한다
      - 이 정보는 도청자 이브에게 노출이 되어도 무방
    - 두 사람은 교환한 정보를 가지고 동일한 키를 각각 생성할 수 없다
      - 도청자 이브는 같은 키를 만들 수 없다
  - 공개 키 암호에 의한 해결
    - 앞에서 배운 대칭 암호
      - 암호화 키와 복호화 키 동일
    - 공개 키 암호
      - 암호화 키와 복호화 키가 다르다
      - 암호화 키를 가지고 있는 사람이라면 누구든지 암호화 할 수 있다
      - 하지만 암호화 키를 가지고 있어도 복호화할 수는 없다
      - 복호화 가능한 사람은 복호화 키를 가진 사람 뿐
    - 과정
      - 수신자는 미리 암호화 키를 송신자에게 알려준다
        - 이 암호화 키는 도청자에게 알려져도 무방
      - 송신자는 그 암호화 키로 암호화해서 수신자에게 전송
      - 암호문을 복호화할 수 있는 자는 복호화 키를 가지고 있는 사람
      - 이렇게 하면 복호화 키를 수신자에게 배송할 필요가 없다

# 공개 키 암호

## 공개 키 암호란

- 암호화 키와 복호화 키가 분리
- 송신자는 암호화 키를 써서 메시지를 암호화, 수신자는 복호화 키를 써서 암호문을 복호화

#### 공개 키 암호의 암호화

- 송신자에게 필요한 것은 암호화 키
- 수신자에게 필요한 것은 복호화 키
- 도청자에게 알려지면 곤란한 것은 복호화 키

#### 공개 키 의미

암호화 키는 일반에게 공개해도 무방 (메일, 신문, 간판, 웹 페이지)

#### 개인 키 의미

- 복호화 키는 미공개
- 본인만 사용

#### 공개키-개인키 쌍

- 키 쌍이라고도 한다
- 공개 키와 개인 키는 둘이 한 쌍
  - 공개 키로 암호화한 암호문은 그 공개 키와 쌍이 되는 개인 키가 아니면 복호화 불가
- 수학적인 관계
  - 키 쌍을 이루고 있는 2개의 키는 서로 밀접한 관계
  - 공개 키와 개인 키 쌍은 별개로 만들 수 없음

#### 공개키 암호의 역사

- 디피와 헬만 (1976)
  - 공개 키 암호의 아이디어를 발표
  - 암호화 키와 복호화 키의 분리성
  - 공개 키가 어떤 특성을 갖춰야 하는지 제시
- 머클(메르클레)과 헬만 (1977)
  - 배낭 암호
- 론 라이베스트, 아디 샤미르, 레너드 애들먼
  - 공개 키 암호 알고리즘 RSA 발표

## 공개 키를 사용한 통신 흐름

- 앨리스가 밥에게 메시지를 보낸다 가정
  - 밥은 공개 키/개인 키로 이루어진 한 쌍의 키 `(KB(pub) / KB(pri))` 생성
  - 밥은 자신의 공개 키를 앨리스에게 전송
  - 앨리스는 밥의 공개 키를 써서 메시지(P)를 암호화`(C = E(KB(pub), P))`
  - 앨리스는 암호문(C)을 밥에게 전송
  - 밥은 자신의 개인 키`(KB(pri))`를 써서 암호문을 복호화`(P = D(KB(pri), C))`

## 관련 용어

#### 대칭 암호

- 동일키 사용해 암호화, 복호화 수행
- 암호화와 복호화가 마치 거울처럼 대칭
- 키: 비밀 키

#### 비대칭 암호

- 대칭 암호와 대비
- 암호화와 복호화에 다른 키 사용
- 키: 개인키와 공개키

## 공개 키 암호로도 해결할 수 없는 문제

#### 공개 키의 인증에 관한 문제

- 입수한 공개 키의 진위를 판단할 필요
- 중간자 공격 (man in hte middle attack)

#### 공개 키 암호의 속도

- 대칭 암호에 비해 처리 속도가 몇 백 배나 늦다

# 시계 연산

바늘이 하나 밖에 없는 시계

## 모드 계산

- mod: 나눗셈을 해서 나머지를 구하는 계산을 위한 기호 연산자
- 27 mod 12
  - 27을 12로 나눈 나머지 = 3
  - 27과 3은 12를 제수로 해서 합동이다라고 표현

## 덧셈

- 바늘이 7을 가리키고 있다
  - 오른 쪽으로 2 눈금으로 보내면 바늘은 어디를 가리키는가 -> 9
  - 오른쪽으로 6 눈금 보내면 바늘은 어디를 가리키는가 -> 1

#### 모드 덧셈

- (7 + 6) mod 12 = 1
- 시계를 오른 쪽으로 돌린다는 것은 덧셈에 해당
- 단순한 덧셈이 아닌 나눗셈의 나머지를 생각

## 뺄셈

- 뺄셈이라는 것은 덧셈의 역의 연산
- 시계의 바늘을 왼쪽으로 돌리면 되는 것
- 이 시계는 오른쪽으로만 감
- 어떻게 빼면 될까
  - 7 - 7 = 왼쪽으로 돌려 0이 되도록 하는 것
  - 오른 쪽으로만 돌려서 0에 도착하려면
  - (7 + 5) mod 12 = 0
  - 5가 -7의 역할을 하기도 한다

## 곱셈

- 곱셈은 덧셈을 반복하는 것
- 7 x 4는 7을 4회 더하기
- 시계 연산에서도 마찬가지로 생각
  - 7 x 4는 7눈금 오른쪽으로 돌리는 조작을 4번 반복
  - 그 다음 모드를 취함
  - 7 x 4 mod 12 = 28 mod 12 = 4

## 나눗셈

- 곱셉의 역연산
- 7 x ? mod 12 = 1
- ? = 7

#### 모드 나눗셈이란

- mod 12의 세계에서 나눗셈을 생각한 것
- 12를 제수로 하는 세계에서는 나머지가 0이 될 수 있다

#### @ x # mod 12 = 1

- @와 #는 모드 12의 세계에서 역수 관계
  - 역수란 서로 곱하면 1이 되는 수
- 보통 산수에서 표현 한다면 @ x 1/@ = 1
  - 즉 역수 #는 1/@ = # 이어야
- 하지만 1/@와 같은 표현은 모드 12의 세계에서는 다르게 표현되어야 한다

#### 모드 12에서 곱셈에 대한 역원

- 그러면 0부터 11까지의 모든 수 @이 역수를 가질까
- 모드 계산에서 어떤 수의 역수가 존재하는지 어떤지 하는 문제는, 공개 키 알고리즘 RSA에서 공개키와 쌍을 이루는 개인키가 존재하는지 어떤지 하는 문제와 직결

#### 역수 계산

- 0의 역수는 있는가
  - 0 눈금의 회전을 아무리 반복해도 1에 바늘이 도달하지 않으므로 존재 하지 않는다
- 1의 역수는 있는가
  - 1 x ? mod 12 = 1
  - 1이다
- 2의 역수는 있는가
  - 2 x ? mod 12 = 1
  - 무엇을 곱해도 짝수가 되므로 없다
- 3, 4 불가
- 5의 역수 5
- 6 불가
- 7의 역수 7
- 8, 9, 10 불가
- 11의 역수 11

#### 역수를 갖는 수

- 1, 5, 7, 11
  - 어떤 성질이 있나
  - 5, 7, 11 소수
  - 하지만 소수하고는 약간 다르다
  - 2, 3은 소수이지만 2, 3은 역수를 갖지 않는다
- mod 12에서 역수를 갖는 수는 12와 그 수가 1 이외의 공통의 약수를 갖지 않는 수 = 최대공약수가 1인 수

## 거듭제곱

- 곱셈이 덧셈을 반복한 것인 것처럼 거듭 제곱은 곱셈을 반복한 것
  - 7의 4제곱, 7을 4회 곱한 것
- 시계에서 거듭 제곱
  - 7의 4승 mod 12 = ?
  - 2401 mod 12 = 1
- 7의 4승 mod 12의 간편식
  - {(7 x 7 mod 12) x (7 x 7 mod 12)} mod 12
  - (49 mod 12 x 49 mod 12) mod 12
  - (1 mod 12 x 1 mod 12) mod 12
  - 1 x 1 mod 12
  - 1 mod 12

## 대수

- 거듭 제곱의 역 연산은 대수라 불린다
- 보통 수학에서 대수 구하는 계산은 그리 어렵지 않다
  - 7의 n승은 49, n은 2
  - 비록 숫자가 커져도 대수를 구하는 계산은 그리 어렵지 않다
  - 사실 수학적으로 X = log7 49 = log7 (7의 2승) = 2

#### 이산 대수

- 시계 계산에 있어서는 이산 대수
- 7의 n승 mod 13 = 8, n은 9
- 활용
  - 모드로 사용되는 숫자가 매우 크면 이산 대수 계산이 매우 어렵고 시간이 대단히 많이 걸림
  - 이산 대수 구하기 고속 알고리즘이 없다
  - 이 두 가지 사실이 비대칭 암호 RSA의 안전성 보장
  - 응용
    - 디피-헬만 키 교환
    - 엘가말 방식의 공개키 암호

## 시계 바늘에서 RSA로

- 7의 4승 mod 12 = 7을 4제곱해서 12로 나눈 나머지라고 읽으면 됨

# RSA

## RSA란 무엇인가

- 공개 키 암호 알고리즘의 하나
- 개발자 3명 이름 앞글자 (Rivest, Shamir, Adleman)
- 응용
  - 공개 키 암호
  - 디지털 서명
  - 키 교환

## RSA에 의한 암호화

- RSA에서 평문도 키도 암호문도 숫자로 변환한 뒤 실행
- RSA의 암호화는 다음 식으로 표현
  - 암호문 = (평문)의 E승 mod N (RSA에 의한 암호화)

#### E와 N

- (E, N): 공개 키
- E와 N이라는 한 쌍의 수를 알면 누구라도 암호화 행할 수 있다
- E와 N이 암호화에 사용되는 키
- E와 N은 면밀한 계산을 통해 생성

## RSA에 의한 복호화

- 평문 = (암호문)의 D승 mod N (RSA에 의한 복호화)

#### D와 N

- (D, N): 개인 키
- D와 N이라는 한 쌍의 수를 알면 누구라도 복호화를 행할 수 있다
- D와 N이 RSA 복호화에 사용되는 키
- D와 N도 면밀한 계산을 통해 생성
- E와 D는 밀접한 연관 관계

## 키 쌍의 생성

- N을 구한다
  - 큰 소수 2개 준비 (p, q) -> (의사난수 생성기, PRNG를 통해)
  - N = p x q
- L을 구한다 (키 쌍 생성 시에만 등장)
  - L = lcm(p - 1, q - 1)
    - lcm은 최소공배수
- E를 구한다
  - 다음 두 식을 만족하는 수 E를 찾는다
  - 1 < E < L
  - gcd(E, L) = 1 (E와 L은 서로소)
    - gcd (최대공약수)
- D를 구한다
  - 다음 두 식을 만족하는 수 D를 하나 찾아낸다
  - 1 < D < L
  - E x D mod L = 1

## 구체적 계산

- 구체적인 수를 써서 RSA의 키 쌍 생성.암호화.복호화를 실제 구현
- 너무 큰 수를 사용하면 계산이 힘들기 때문에 작은 수를 이용하여 계산
- 예
  - p와 q 선택: p = 17, q = 19
  - N 구하기: N = p x q = 17 x 19 = 323
  - L 구하기: L = lcm(p - 1, q - 1) = lcm (16, 18) = 144
  - E 구하기
    - gcd(E, L) = 1이 되는 수 E를 선택
    - E가 될 수 있는 수는 다음과 같은 수
    - 5, 7, 11, 13, 17 ,19, 23, 25, 29, 31, ...
    - 우리는 E = 5를 선택(다른 수를 선택해도 무방)
  - D 구하기: E x D mod L = 5 x 29 mod 144 = 145 mod 144 = 1 이므로 D는 29
  - 공개 키: (E, N) = (5, 323)
  - 개인 키: (D, N) = (29, 323)
  - 암호화
    - 평문은 N = 323 보다 작은 수
    - 평문은 = 123이라고 생각
    - 평문의 E승 mod N = 123의 5승 mod 323 = 225 = 암호문
  - 복호화
    - 암호문의 D승 mod N = 225의 29승 mod 323 = 123 = 평문

# RSA에 대한 공격

- 해독자가 알고 있는 것 or 알 수 있는 것
  - 암호문: 도청해서 구할 수 있음
  - E와 N: 공개 키
- 해독자가 모르는 것
  - 평문: 지금부터 해독하려고 하는 내용
  - D: 개인 키 중 적어도 D는 모름
  - 기타: 키 쌍을 만든 p, q, L 모름

## 암호문으로부터 평문 구하기

- 암호문 = 평문의 E승 mod N 에서 평문을 구하려면 이산 대수 문제를 풀어야 (이산 대수 문제는 매우 곤란함)
- 현재까지 아직 이산 대수를 구하는 빠른 방법을 알지 못함

## 전사 공격

- D의 후보가 되는 수를 순서대로 모두 시도해서 복호화해본다
- D의 비트 수가 크면 클수록 어려워진다
- 비트 수가 충분히 크면 전사공격으로 수 D를 찾는 것은 현실적으로 불가능
- RSA에서는 p와 q의 비트 수로서 512 비트 이상 사용
- N은 1024 비트 이상을 이용
- E나 D는 N과 같은 정도의 크기로 할 수 있으므로 D를 찾으려면 1024 비트 이상의 전사공격 필요 (현실적 불가능)

## E와 N으로부터 D 구하기

E X D mod L = 1

- L은 lcm(p-1, q-1)이므로 E로부터 D를 계산할 때는 p와 q를 사용
- 암호해독자는 p와 q를 전혀 모름
- 해독자는 D를 구할 수 없음
- RSA의 안전성을 위해 소수 p와 q를 암호 해독자가 모르게 해야 함

## N의 소인수분해

- N = p x q라는 관계식을 공격자는 알고 있고 N은 공개되어 있다
- N으로부터 p와 q를 구할 수는 없는 것일까?
- p와 q는 소수이기 때문에 N으로부터 p와 q를 구한다는 것은 자연수 N을 `소인수분해`하는 것
  - 큰 수를 고속으로 소인수분해 할 수 있는 방법이 발견되면 RSA를 깰 수 있다
  - 그러나 큰 수의 소인수분해를 고속으로 행하는 방법은 아직 발견되지 못함
  - 소인수분해를 간단히 수행하는 방법이 존재하는지의 여부도 아직 모름

## p와 q 추측하기

- 소인수분해를 하지 않아도 p와 q가 암호 해독자에게 알려질 가능성은 있다
- p와 q는 의사난수 생성기로 생성하기 때문에 의사난수 생성기의 품질이 나쁘면 p와 q를 암호 해독자가 추측할 수 있다
- 난수 생성기가 강력해서 암호 해독자가 추측할 수 없어야 한다

## 기타 공격

- N을 소인수분해 해서 p와 q를 구할 수 있으면 D를 구할 수 있다
- D를 구하는 것이 N을 소인수분해 하는 것과 수학적으로 같은지 아닌지가 증명되어 있지 않다
- N을 소인수 분해 하지 않아도(p와 q를 몰라도) E와 N으로부터 D를 구하는 방법이 있을 수도 있다

## 중간자 공격

- RSA를 해독하는 게 아님
- 기밀성을 침해하는 공격
- 공격자 맬로리가 송신자와 수신자 사이에서 송신자에 대해서는 수신자처럼, 수신자에 대해서는 송신자처럼 행새하는 공격

#### 절차

- 앨리스는 밥의 공개 키 요청
- 맬로리는 앨리스의 요청을 도청
- 밥은 자신의 공개 키(KB(pub))를 앨리스에게 전송
- 맬로리는 밥의 이 메일이 앨리스에게 도달하지 못하도록 하고, 밥의 공개 키를 보존
- 맬로리는 자신의 공개 키(KM(pub))를 밥의 공개키라고 속여서 앨리스에게 전송
- 앨리스는 자신의 메시지(P)를 밥의 공개 키(실은 맬로리의 공개 키)로 암호화 (C=E(KM(pub), P))
- 앨리스는 암호화한 메시지(C)를 밥에게 전송
- 맬로리는 앨리스의 암호 메일을 갈취해서 자신의 개인키(KM(pri))로 복호화(P=D(KM(pri, C)))하고 평문(P)을 확보
- 맬로리는 앨리스 행세를 하며 위조 메일(P 프라임)을 만들고 위으 단계(4)에서 보존해 둔 밥의 공개 키(KB(pub))를 써서 이 위조 메일을 암호화(C 프라임 = E(KB(pub), P 프라임))하여 밥에게 전송
- 밥은 받은 암호 메일(C 프라임)을 자신의 개인키로 복호화하고 메일(P 프라임)을 읽게 된다

# 선택 암호문 공격

- 복호 오라클
  - 임의의 데이터를 송신하면 그것을 암호문으로 간주하고 회신해주는 서비스
- 선택 암호문 공격
  - 복호 오라클 공격을 공격자가 이용할 수 있다고 가정한 공격
  - 공격 대상인 암호문은 제외

## 복호 오라클 서비스의 의미

- 넌센서츠럼 보이지만 실제 네트워크에서 오류메시지 반환을 악용하는 공격
- 위조 암호문을 여러 차례 전송하여 반환된 오류 메시지나 타이밍 정보를 활용해 평문을 추측
- RSA의 경우 선택 암호문 공격으로 약간의 정보 취득 가능

## RSA-OAEP(Optimal Asymmetric Encryption Padding)

- RSA를 개량해서 선택 암호문 공격으로부터 안전하게 만든 것
- 암호문에 인증 과정을 추가한 방법
- 평문 해시 갑소가 정해진 개수의 0 등으로 만들어진 인증정보를 평문 앞에 추가한 뒤 그 후에 RSA로 암호화한다
- 복호화 시 RSA로 복호화한 후 선두에 올바른 인증 정보가 나타나지 않으면 오류 판정

# 기타 공개키 암호

## ElGamal 방식

- RSA는 소인수 분해 어려움이라면 ElGamal 방식은 이산 대수를 구하는 것이 어렵다는 것을 이용
- 암호화에서는 암호문의 길이가 평문의 2배가 되어버린다는 결점이 있다
- GnuPG에서 사용

## Rabin 방식

- mod N으로 평방근(제곱근)을 구하는 것이 어렵다는 사실을 이용
- 공개 키 암호의 해독은 소인수분해 정도로 어렵다는 것이 증명

## 타원곡선 암호

- 최근 주목받음
- RSA에 비해 키의 비트 수가 적다
- 타원 곡선 위에 곱셈을 정의하고 이 곱셈의 역 연산이 어렵다는 것을 이용

# 공개 키 암호에 관한 Q&A

## 공개 키 암호의 기밀성

의문: 공개 키 암호는 대칭 암호보다도 기밀성이 높은가

> 이것 만으로는 답할 수 없다
>
> - 왜냐하면 키의 비트 길이에 따라 기밀성의 정도는 변화하기 때문

## 공개 키 암호와 대칭 암호의 키 길이

의문: 1024비트 길이의 키를 갖는 공개 키 암호와 128비트 길이의 키를 갖는 대칭 암호에서는 비트 길이가 긴 공개 키 암호 쪽이 안전한가

> 공개 키 암호의 키 길이와 대칭 암호의 키 길이는 직접 비교할 수 없다

#### 전사공격에 대한 강도를 갖는 키 길이 비교

| 대칭    | 공개 키  |
| ------- | -------- |
| 128비트 | 2304비트 |
| 112비트 | 1792비트 |
| 80비트  | 768비트  |
| 64비트  | 512비트  |
| 56비트  | 384비트  |

## 대칭 암호의 미래

의문: 공개 키 암호가 생겼기 때문에 앞으로 대칭 암호는 사용할 필요가 없는가?

> 아니다
>
> - 일반적으로 같은 정도의 기밀성을 갖는 키 길이의 경우, 공개 키 암호는 대칭 암호바도다 몇 백 배나 느리다
> - 공개 키 암호는 긴 메시지를 암호화 하기에는 적합하지 않다
> - 목적에 따라 모두 사용해야

## RSA와 소수

의문: RSA의 키 쌍을 모두가 자꾸 만들어 가면 그 사이 소수가 없어져 버리는 것은 아닌가

> 그럴 염려는 없다. 512비트로 표현할 수 있는 소수의 수는 대략 10의 150승으로 전 우주에 존재하는 원자의 개수보다도 많은 수

## RSA와 소인수 분해

#### 의문: RSA로 암호화할 때 큰 수를 소인수분해 할 필요가 있는 것일까

> 아니다
>
> - RSA의 암호화에서도, 복호화에서도, 그리고 키 쌍의 생성에서도 큰 수를 소인수분해를 할 필요는 없다

#### 의문: RSA를 해독하는 것은 큰 수를 소인수분해 하는 것과 같은 것인가

> 같은 것인지 아닌지 아직 모름
>
> - 분명히 소인수분해를 고속으로 할 수 있다면 RSA는 해독됨
> - RSA를 해독하려면 소인수분해를 꼭 해야 한다는 것이 증명된 것은 아님
> - 어쩌면 소인수분해를 하지 않아도 해독할 수 있는 방법이 발견될지도 모름

## RSA의 비트 길이

의문: 소인수분해 되지 않기 위해서는 N은 몇 비트 길이가 필요한가

> 아무리 비트 수가 커도 언젠가는 소인수분해 된다 (현실적인 시간 안에 되는지 아닌지가 문제)

#### 512 비트 수 하나 인수분해하기

- 512비트로 주어진 한 수는 1999년 8월에 소인수분해
- 9주 간의 사전 계산과 5.2개월 간에 걸친 292대의 컴퓨터에 의한 계산이 필요
- 이만큼의 컴퓨터 자원과 시간을 들여서 겨우 1개의 수를 소인수분해 가능했음

#### 704비트 N

- RSA사가 제시한 704비트 N(212자리 10진수)
- 아직 인수분해 되지 않음
- 상금은 3만불

# 이 장의 정리

- 공개 키 암호: 키 배송 문제 해결, 중간자 공격 가능
- 기밀성 유지
  - 대칭 키: 평문을 복잡한 형태로 변환
  - 공개 키: 수학적으로 해결하기 곤란한 문제를 토대로 함
- RSA: 큰 수의 소인수 분해 이용
- 공개 키 암호의 실행속도가 대칭 암호보다 훨씬 느리다
- 하이브리드 암호 시스템: 대칭 암호로 처리 속도를 높이고 공개 키 암호를 써서 키 배송 문제를 해결하는 것

# 퀴즈

## 키 배포 센터의 처리

앨리스가 밥과 통신하고 싶다고 신청했을 때, 키 배포 센터는 세션 키라는 것을 일부러 새로 만들어서 그것을 암호화해서 앨리스에게 건네 주었다. 어째서 키 배포센터는 밥의 키를 앨리스의 키로 암호화해서 앨리스에게 건네지 않은 것일까?

> 만약 앨리스에게 밥의 키를 건네게 되면, 그 이후 앨리스는 (이번 통신이 끝난 뒤라도) 밥의 키로 암호화한 암호문을 복호화할 수 있다. 즉 앨리스가 밥의 도청자가 될 가능성이 있다

## 2개의 암호 알고리즘

키 배송 문제 이야기를 들은 앨리스는 이렇게 생각했다 `"키를 수신자에게 보내면 도청되므로 곤란하다는 것이 키 배송 문제라고 생각했다. 키를 그대로 보내니까 문제가 되는 게 아닐까? 먼저 메시지는 AES로 암호화해 둔다. 그리고 나서 암호화에 사용한 AES의 키를 트리플 DES로 암호화해서 보내면 되지 않을까? AES의 키는 트리플 DES로 암호화되어 있으니까 도청되어도 괜찮을 거야"`

> 앨리스의 방법으로는 트리플 DES의 키 배송 문제가 해결되지 않았다. 분명히 AES의 키를 트리플 DES로 암호화해서 보내면 암호화된 AES의 키는 도청되어도 괜찮으나 AES의 키를 암호화했을 때 사용한 키(트리플 DES의 키)를 배송하지 않으면 수신자는 암호화된 AES의 키를 복호화할 수 없다. 따라서 키 배송 문제를 해결한 것이 아님

## 거듭제곱의 mod

7의 16승 mod 12 값을 구하시오.

> a) 1 이 된다. `33232930569601 mod 12 = 1`
> b) ((7의 4승 mod 12) \* (7의 4승 mod 12) \* (7의 4승 mod 12) \* (7의 4승 mod 12)) mod 12
>
> - 1 mod 12
> - 1

## 공개 키 암호의 기초 지식

- 공개 키 암호로 암호화할 때 수신자의 공개 키가 필요하다. O
- 공개 키 암호로 암호화된 암호문을 복호화하기 위해서는 공개 키 암호와 쌍을 이루고 있는 개인 키가 필요하다. O
- 공개 키 암호의 개인 키는 암호화한 메시지와 함께 수신자에게 송신할 필요가 있다. X
- 일반적으로 공개 키 암호보다는 대칭 암호 쪽이 빠르다. O
- 소인수 분해를 고속으로 푸는 방법이 발견되면 RSA도 고속으로 풀 수 있다. O

---

# 하이브리드 암호 시스템

## 대칭 암호와 공개 키 암호

- 대칭 암호
  - 기밀성을 유지한 통신이 가능
  - 키 배송 문제 해결이 필요
- 공개 키 암호
  - 키 배송 문제를 해결할 수 있다

#### 공개 키 암호의 큰 문제

- 대칭 암호에 비해 처리 속도가 훨씬 느림
- 중간자 공격에 약하다

> 하이브리드 암호 시스템을 이용하면 이 중 처리 속도 문제 해결 가능

## 하이브리드 암호 시스템

- 대칭 암호와 공개 키 암호의 장점을 조합한 방법
- 메시지의 기밀성: 고속의 대칭 암호
- 대칭 암호 키의 기밀성: 공개 키 암호

#### 구조

- 메시지는 대칭 암호로 암호화
- 대칭 암호의 암호화에서 사용한 세션 키는 의사난수 생성기로 생성
- 세션 키는 공개 키 암호로 암호화
- 공개 키 암호의 암호화에서 사용하는 키는 하이브리드 암호 시스템과 무관한 외부에서 만들어 사용

## 암호화

#### 표현 방법

평문.키.암호문

- P: 평문
- Kpub: 수신자의 공개 키
- C2: 공개 키 암호로 암호화된 세션 키
- C1: 대칭 암호로 암호화된 메시지
- C=(C1, C2): 암호문

#### 메시지 암호화

- C1 = E(K, P)
- 대칭 암호 이용해서 암호화
- 대칭 암호를 이용하면 고속으로 암호화

#### 세션 키 암호화

- C2 = E(Kpub, K)
- 수신자의 공개 키로 암호화됨
- 세션 키는 짧음
- 공개 키 암호가 아무리 느려도 세션 키 암호화에 그다지 오랜 시간이 걸리지 않는다
- 세션 키는 대칭 암호에 있어서는 키이지만, 공개 키 암호의 입장에서 보면 하나의 평문

#### 결합

- 대칭 키(K)로 암호화된 암호문(C1 = E(K, P))
- 수신자의 공개 키(Kpub)로 암호화된 세션 키(C2 = E(Kpub, K))
- 암호문: C = C2 || C1 = E(Kpub, K) || E(K, P)

## 복호화

#### 분할

- 암호문: C = C2 || C1 = E(Kpub, K) || E(K, P)을 분할
  - C1 = E(K, P): 대칭 키(K)로 암호화된 암호문
  - C2 = E(Kpub, K): 수신자의 공개 키(Kpub)로 암호화된 세션 키

#### 세션 키 복호화

- C2 = E(Kpub, K) 복호화
- 수신자의 개인 키(Kpri)가 필요
  - 개인 키를 가지고 있는 사람이 아니면 세션 키를 복호화 할 수 없다
- K = D(Kpri, C2): 수신자의 개인 키로 복호화된 세션 키는 메시지 복호화 키로 이용

#### 메시지 복호화

- P = D(K, C1)

## 하이브리드 암호 시스템의 구체 예

- PGP
  - 하이브리드 암호 시스템
  - 디지털 서명이나 디지털 서명의 검증
  - 개인 키 관리
- SSL/TLS
  - 하이브리드 암호 시스템
  - Web의 암호 통신에서 사용

# 지난 주 복습

- 하이브리드 암호 시스템
  - 대칭 암호와 공개 키 암호의 장점을 조합한 방법
  - 메시지의 기밀성: 고속의 대칭 암호
  - 대칭 암호 키의 기밀성: 공개 키 암호
- 하이브리드 암호 시스템의 구조
  - 메시지는 대칭 암호로 암호화
  - 대칭 암호의 암호화에서 사용한 세션 키는 의사난수 생성기로 생성
  - 세션 키는 공개 키 암호로 암호화
  - 공개 키 암호의 암호화에서 사용하는 키는 하이브리드 암호 시스템과 무관한 외부에서 만들어 사용

# 강한 하이브리드 암호 시스템이란

- 하이브리드 암호 시스템의 구성 요소
  - 의사난수 생성기
  - 대칭 암호
  - 공개 키 암호
- 각각의 기술 요소의 강도
- 강도의 밸런스도 중요

## 의사난수 생성기

- 세션 키 생성에 사용
- 품질이 나쁘면 만들어지는 세션 키를 공격자가 추측하게 될 위험성
- 세션 키 중 일부 비트라도 추측되지 않도록 주의

## 대칭 암호

- 메시지 암호화에 사용
- 강한 대칭 암호 알고리즘을 사용
- 충분히 길이가 긴 키 사용
- 적절한 블록 암호 모드 사용

## 공개키 암호

- 세션 키 암호화에 사용
- 강한 공개 키 암호 알고리즘 사용
- 충분히 길이가 긴 키 사용

## 키 길이의 밸런스

- 어느 쪽인가 한 쪽의 키 길이가 극단적으로 짧으면, 공격이 그쪽으로 집중될 가능성이 있음
- 대칭 암호와 공개 키 암호의 키 길이는 양쪽이 같은 정도의 강도가 되도록 길이의 균형을 맞춤
- 장기간의 운용을 고려한다면 대칭 암호보다도 공개 키 암호 쪽을 강하게

# 암호 기술의 조합

- 하이브리드 암호 시스템
  - 대칭 암호와 공개 키 암호를 조합해서 양쪽의 장점을 살리는 시스템을 구축
- 블록 암호 모드
  - 고정 키 길이밖에 암호화할 수 없는 블록 암호를 조합해서 보다 긴 평문을 암호화
- 트리플 DES
  - DES를 3개 조합해서 DES보다도 긴 키 길이를 갖는 대칭 암호
- 디지털 서명
  - 일방향 해시 함수와 공개 키 암호를 조합
- 인증서
  - 공개 키와 디지털 서명을 조합
- 메시지 인증 코드
  - 일방향 해시 함수와 키를 조합
  - 대칭 암호로부터 생성
- 의사난수 생성기
  - 대칭 암호
  - 일방향 해시 함수
  - 공개 키 암호

## 기타

- 전자 투표
- 디지털 캐시
- 블라인드 서명
  - 내용을 모르고 서명
- 영 지식 증명
  - 상대에게 정보를 건네지 않고 자신이 그 정보를 가지고 있다는 사실만을 증명해 보이는 방법

# 퀴즈

## 하이브리드 암호 시스템의 기초 지식

- 하이브리드 암호 시스템에서는 대칭 암호를 써서 메시지를 암호화 한다 -> O
- 하이브리드 암호 시스템에서는 공개 키 암호의 개인 키를 써서 메시지를 암호화한다 -> X
- 세션 키는 공개 키 암호로 암호화되기 때문에 세션 키의 비트 길이는 짧아도 상관 없다 -> X (전사 공격에 대한 위험 증가)
- 하이브리드 암호 시스템의 복호화에서는 공개 키 암호의 복호화 -> 대칭 암호의 복호화의 순서로 처리가 진행된다 -> O

---

# 일방향 해시 함수

## 파일의 진위

- 어제 저장한 파일과 오늘의 파일 비교
  - 밤새 맬로리가 파일을 변경했는지 어떤지를 조사하고 싶다
- 무결성
  - 파일이 변경되지 않았다
- 파일의 무결성을 조사하고 싶다
  - 파일을 안전한 장소에 저장후 오늘 불러온 파일과 비교하여 무결성 확인
- 파일의 지문은 없을까
  - 파일 전체를 비교하는 대신 작은 지문 비교하는 것만으로도 무결성 확인 가능하면 매우 편리할 것

#### 해시 값 비교 방법

- 어제 만든 파일 해시 함수를 통해 해시 저장
- 오늘 불러온 파일 해시 함수로 나온 해시와 어제 저장한 해시 비교

## 일방향 해시 함수란

- 파일의 지문 채취 기술
- 일방향 해시 함수가 만들어내는 해시 값은 메시지의 지문에 해당
- 예
  - 입력: 임의의 숫자
  - 처리: 입력되는 숫자를 23으로 나누는 메커니즘
  - 출력: 그 몫을 소수로 표현했을 때 소숫점 이하 7자리부터 10자리까지 4자리 숫자
- 입력과 출력이 각각 1개씩 있다
- 입력은 메시지
- 출력은 해시 값
- 일방향 해시 함수는 메시지를 기초로 해서 해시 값을 계산

#### 일정한 크기의 출력

- 해시 값의 길이는 메시지의 길이와는 관계가 없다
- 메시지가 1비트라도, 1메가바이트라도, 100기가바이트라도 일방향 해시 함수는 고정된 길이의 해시 값을 출력
- SHA-1의 출력은 항상 160비트

## 일방향 해시 함수의 성질

- 임의의 길이 메시지로부터 고정 길이의 해시 값을 계산
  - 어떠한 크기 메시지라도 크기에 관계 없이 입력으로 사용할 수 있어야
  - 어떤 길이의 메시지를 입력으로 주더라도 일방향 해시 함수는 짧은 해시 값을 생성
- 해시 값을 고속으로 계산 가능
  - 해시 값 계산은 고속이어야
  - 메시지가 길어지면 해시 값을 구하는 시간이 길어지는 것은 어쩔 수 없다
  - 현실적인 시간 내에 계산할 수 없다면 소용 없다
- 메시지가 다르면 당연히 해시 값도 다르다
  - 메시지가 1비트라도 변화하면 해시 값은 매우 높은 확률로 다른 값이 돼야 한다
- 일방향성을 갖는다
  - 해시 값으로부터 메시지를 역산할 수 없다
  - 메시지로부터 해시 값을 계산하는 것은 간단히 할 수 있다
  - 해시 값으로부터 메시지를 계산하는 것은 불가능해야

#### 해시 함수의 충돌

- 충돌: 2개의 다른 메시지가 같은 해시 값을 갖는 것
- 충돌 내성: 충돌을 발견하는 것이 어려운 성질
  - 약한
    - 어느 메시지의 해시 값이 주어졌을 때, 그 해시 값과 같은 해시 값을 갖는 다른 메시지를 발견해 내는 것이 매우 곤란한 성질
  - 강한
    - 해시 값을 일치할 것 같은 다른 2개의 메시지를 발견해 내는 것이 매우 곤란한 성질

## 해시 함수 관련 용어

- 일방향 해시 함수
  - 메시지 다이제스트 함수
  - 메시지 요약 함수
  - 암호적 해시 함수
- 일방향 해시 함수의 입력이 되는 메시지
  - 프리.이미지
- 해시 값
  - 메시지 다이제스트
  - 핑거프린트
- 무결성
  - 완전성
  - 보전성

# 일방향 해시 함수의 응용

## 소프트웨어의 변경 검출

- 자신이 입수한 소프트웨어가 변경 되었는지를 확인하기 위해 일방향 해시 함수를 사용

## 패스워드를 기초로 한 암호화

- PBE에서는 패스워드와 솔트를 섞은 결과의 해시 값을 구해 그것을 암호화 키로 사용
- 패스워드 사전 공격 방어

## 메시지 인증 코드

- 송신자와 수신자만이 공유하고 있는 키와 메시지를 혼합해서 그 해시 값을 계산한 값
- 통신 중의 오류나 수정 그리고 가장(위장)을 검출 가능
- SSL/TLS에서 이용

## 디지털 서명

- 현실 사회의 서명이나 날인에 해당하는 온라인 상의 서명
- 처리 시간 단축을 위해 일방향 해시 함수를 사용해서 메시지의 해시 값을 일단 구하고, 그 해시 값에 대해 디지털 서명 수행

## 의사난수 생성기

- 일방향 해시 함수를 이용한 의사난수 생성
- 암호 기술에 필요한 난수
  - 과거의 난수열로부터 미래의 난수열을 예측하는 것은 사실상 불가능이라는 성질이 필요
  - 그 예측 불가능성을 보증하기 위해 일방향 해시 함수의 일방향성을 이용

## 일회용 패스워드

- 원타임 패스워드
  - 정당한 클라이언트인지 아닌지를 서버가 인증할 때에 사용
  - 일방향 해시 함수를 써서 통신 경로 상에 흐르는 패스워드를 1회만 사용하도록 고안
  - 패스워드가 도청되어도 악용될 위험성이 없다

# 일방향 해시 함수의 예

## MD4와 MD5

#### MD4

- 라이베스트가 1990년에 만든 일방향 해시 함수
- 128비트의 해시 값
- Dobbertin에 의해 충돌 발견 방법 고안
- 현재는 안전하지 않다

#### MD5

- 라이베스트가 1991년에 만든 일방향 해시 함수
- 128비트의 해시 값
- 암호해독에 취약함을 보여주는 여러 가지 암호해독 방법들이 개발
- MD5가 완전히 뚫린 것은 아님
  - MD5 내부 구조 일부에 대한 몇 가지 공격 방법 발견
- 사용 권장 안함

## SHA-1, SHA-256, SHA-384, SHA-512

#### SHA-1

- NIST에서 제작
- 160비트의 해시 값
- SHA
  - 1993년에 미국의 연방정보처리표준
- SHA-1
  - 1995년에 발표된 개정판
  - 2005년에 암호학적으로 공격에 취약한 것이 밝혀짐
  - 2010년 이후로는 호환성 유지 목적으로만 사용

#### SHA-2

- SHA-256
  - 256 비트의 해시 값
  - 메시지의 길이 상한 2의 64비트 미만
- SHA-384
  - 256 비트의 해시 값
  - 메시지의 길이 상한 2의 128비트 미만
- SHA-512
  - 512 비트의 해시 값
  - 메시지의 길이 상한 2의 128비트 미만

## RIPEMD-160

- 1996년에 Hans Dooberitn, Antoon Bosselaers, Bart Preneel이 제작
- 160비트의 해시 값
- 유로피안 유니온 RIPE 프로젝트로 만들어진 RIPEMD 함수의 개정판
- 비트코인에서 사용
- 별도 버전
  - RIPEMD-128, RIPEMD-256, RIPEMD-320

## SHA-3

- SHA-1의 강한 충돌 내성 침해
- NIST는 SHA-1을 대체하는 차세대 일방향 해시 함수로 2007년에 SHA-3 선정 시작
- AES와 같은 경쟁 방식으로 표준화
- 2012년 선정 완료
  - KECCAK을 표준으로 선정
  - 이것이 SHA-3

# 일방향 해시 함수 SHA-512

## 구조

- 입력: 최대 2의 128비트 이하 메시지
- 출력: 512비트 메시지 다이제스트
- 입력 데이터는 길이 1024비트 블록으로 처리

## 처리 단계

- 패딩 비트 붙이기
  - 메시지 뒤에 여분의 데이터를 부가하여 메시지의 길이가 896 (mod 1024)가 되도록 만듦
  - 메시지가 1024비트의 배수여도 패딩 추가
  - 패딩의 첫 번째 비트는 1
  - 나머지 비트는 모두 0
- 길이 붙이기
  - 128비트 블록 K를 메시지에 추가
  - 1024 비트 블록들을 M1, M2, ..., MN으로 표현
  - 총 길이 = N \* 1024 비트
- MD 버퍼 초기화
- 1024-비트(128-워드) 블록 메시지 처리
  - 각 라운드가 80 라운드로 구성
  - 각 라운드에서 512 비트 버퍼 abcdefgh를 입력으로 사용
- 출력
  - N개의 1024-비트 블록을 모두 처리하면 N번째 단계에서 512-비트 메시지 다이제스트가 출력

## 안전성

- 2017년까지 약점 발견된 것 없음
- 확률적 안전성
  - 약 충돌성: 동일한 메시지 다이제스트를 갖는 두 개의 서로 다른 메시지를 찾는 난이도 연산 수행 수는 2의 256승
  - 강 충돌성: 주어진 다이제스트와 동일한 다이제스트를 갖는 메시지를 찾는 난이도 연산 수행 수는 2의 512승

# SHA-3 선정 과정

## SHA-3란 무엇인가

- 이론적 공격방법이 알려져 버린 SHA-1을 대신하는 새로운 표준의 일방향 해시 알고리즘
- 2012년에 KECCAK이라는 알고리즘을 SHA-3으로 선정

## SHA-3 선정 과정

- 미국 표준화 기관 NIST에서 공모
- 실질적으로는 세계적인 표준
- 경쟁방식에 의한 표준화 방식으로 선정

## SHA-3 최종 후보와 SHA-3 결정

- NIST에서 2007년에 SHA-3 공모
- 2008년까지 응모한 알고리즘 수는 64개
- 2010년에 SHA-3 최종후보로서 5개의 알고리즘이 선정
- SHA-2와 SHA-3 공존해서 사용
- KECCAK이 SHA-3로 선정된 이유
  - SHA-2와 전혀 다른 구조
  - 구성이 투명하여 구조를 해석하기 쉬움
  - 다양한 디바이스에서 구동되고 조합 형태로도 양호
  - 하드웨어 상에 내장 시 높은 고성능
  - 다른 최종 목록과 비교하여 보안성이 높음

# KECCAK

## KECCAK이란 무엇인가

- SHA-3으로 선정된 일방향 해시 함수 알고리즘
- 해시 값으로서 임의 길이의 비트열 생성
- SHA-2 비트 길이에 맞춰져 있음
- SHA3-224, SHA3-256, SHA3-384, SHA3-512 4종류가 SHA-3으로 규정
- 입력 데이터 크기에 제한 없음
- SHAKE128과 SHAKE256이라는 임의 길이의 출력을 가진 함수 (extendable-outpu function; XOF)를 규정
  - SHAKE = Secure Hash Algorithm + KECCAK

## 스펀지 구조

- SHA-1과 SHA-2와는 전혀 다른 스펀지 구조가 사용됨
- 입력되는 메시지에 패딩을 시행한 후 흡수 단계와 추출 단계라는 두 개의 상태를 통해서 해시 값을 출력

#### 흡수 단계

- 패딩된 입력 메시지를 r 비트 단위의 입력 블록으로 분할
- 우선 내부 상태의 r 비트와 입력 블록 1의 XOR을 구하고 그것을 함수 f에 입력
- 다음에 함수 f의 출력 r 비트와 입력블록 2을 XOR하고, 그것을 다시 한 번 함수 f에 입력
- 이 과정을 입력 블록이 다 할 때까지 계속
- 입력 블록을 다 처리하면 흡수 단계를 종료하고 추출 단계를 진행

#### 추출 단계

- 우선 함수 f의 출력 중 r 비트를 출력 블록 1로 기술하고 출력전체(r + c 비트)는 함수 f로 다시 입력
- 다음에 함수 f 출력 중 r 비트를 출력 블록 2로 기술하고, 출력전체(r + c 비트)는 함수 f로 다시 입력
- 이것을 필요한 비트 수의 출력을 얻을 때까지 계속 반복

## 듀플렉스 구조

- 입력과 출력이 같은 속도로 진행
- 해시 값을 구하는 용도만이 아니라 의사난수 생성기, 스트림 암호, 인증이 포함된 암호, 메시지 인증 코드 등 암호학자의 도구상자에 들어있는 대부분의 기능을 활용할 수 있음

## KECCAK의 내부 상태

- 3차원 비트 배열
- 1비트를 나타내는 작은 입방체가 b개, 즉, 5 x 5 x z 방향수 만큼 큰 육면체
- 내부 상태의 일부
  - 상태(state)
    - x, y, z의 모든 방향을 고려한 3차원 내부상태 전체
  - 플레인: x, z
  - 슬라이스: x, y
  - 시트: y, z
  - 로우: x
  - 칼럼: y
  - 레인: z
  - 비트: 하나

## 함수 KECCAK-f[b]

- 내부 상태를 혼합하는 함수
- b를 폭이라고 함
  - b = 25, 50, 100, 200, 400, 800, 1600 7종류
  - SHA-3에서는 b = 1600 사용
  - SHA-3의 내부상태 b = 5 x 5 x 64 = 1600 비트
- 아래에 설명하게 될 세타, 로우, 파이, 카이, 아이오타라는 5개 단계를 1라운드라고 할 때 총 12 + 2아이오타 라운드를 반복하는 함수
- SHA-3으로 사용되는 KECCAK-f[1600]의 경우 라운드 수는 24

## 세타 단계

위치를 이동시킨 칼럼 2개의 5 비트를 XOR하여 그 결과를 목적 비트와 XOR 처리 후 목적 비트를 대체

## 로우 단계

z방향(레인 방향) 비트 이동

## 파이 단계

비트 이동을 레인 전체에 대해 수행

## 카이 단계

논리회로 NOT과 AND 연산을 활용하여 수행

## 아이오타 단계

- 라운드 정수라고 불리는 정수와 단계 전체의 비트를 XOR 처리
- 내부 상태의 비대칭성을 위해 수행

## KECCAK에 대한 공격

- MD변환
  - MD4, MD5, RIPEMD, RIPEMD-160, SHA-1, SHA-2 등, 지금까지 거의 일방향 해시 함수 알고리즘에서 이용
- SHA-1에 대한 논리적인 공격방법이 발견
- SHA-2는 SHA-1과 같은 MD구조를 사용했기 때문에 근본적으로 문제를 해결할 필요가 있음
- KECCAK은
  - MD구조와 다른 스펀지 구조로 만들어져 있기 때문에 SHA-1을 공격한믄 데 사용된 방법이 KECCAK에는 통용되지 않음
  - 현재까지 공격 방법이 알려진 것이 없음

## 약한 KECCAK에 대한 공격 테스트

- KECCAK은 반복되는 구조로 되어 있고 여러 라운드로 구성됨
- 약한 KECCAK을 구성하는 것이 가능
- KECCAK Crunch Crypto Collision and Pre-image Contest
  - 구조를 명확히 해 해석이 쉽도록 간략형 KECCA을 만들고 이를 공격해보는 콘테스트
  - SHA-3의 안전도 측정 방법

# 일방향 해시 함수에 대한 공격

## 전사 공격

- 일방향 해시 함수의 약한 충돌내성을 깨고자 하는 공격
- 맬로리는 앨리스의 컴퓨터에서 계약서 파일을 발견하고 그 안의 앨리스의 지불금액 100만원을 1억원으로 바꿈
- 문서의 의미를 바꾸지 않고 얼마만큼 파일을 수정할 수 있을까, 동일한 내용을 다른 형태로 표현
- 그 중 앨리스가 만든 오리지널 계약서와 같은 해시 값을 생성하는 것을 발견할 때 까지 작성해봄

## 생일 공격

- 강한 충돌 내성을 깨고자 하는 공격
- 맬로리는 해시 값이 같은 값을 갖는 100만원 계약서와 1억원 계약서를 미리 만들어 둔다
- 맬로리는 시치미를 떼고 100만원 계약서를 앨리스에게 건네주고 해시 값을 계산 시킨다
- 맬로리는 스토리1과 마찬가지로 100만원 계약서와 1억원 계약서를 살짝 바꾼다
- N명 중 적어도 2명의 생일이 일치할 확률이 2분의 1 이상이 되도록 하기 위해서는 N은 최저 몇 명이면 될까
  - 23명
  - 어느 특정일을 정하고 2명이 그 날 태어날 가능성은 높지 않다
  - 그러나 1년의 어느 날이라도 상관 없으므로 2명이 같은 날 태어날 가능성은 의외로 높다
- 맬로리는 100만원 계약서 1억원 계약서 N개 작성
- 맬로리는 각각의 계약서끼리 비교해서 일치하는 것이 있는지 찾는다
- 발견되면 두 계약서를 가지고 속이러 간다

#### N의 크기

- 문제가 되는 것은 N의 크기
- N이 작으면 공격 성공 가능 높음
- N이 크면 시간도 메모리도 많이 필요해서 생일 공격은 어려워짐
- N은 해시 값의 비트 길이에 의존

## 스토리 비교

- 스토리1
  - 앨리스가 백 만원 계약서를 만들어서 해시 값은 고정
  - 맬로리는 그 해시 값과 같은 메시지를 발견해 내는 약한 충돌 내성 공격
- 스토리2
  - 맬로리가 2 개의 계약서를 만드는 것이므로 해시 값은 뭐라도 상관 없음
  - 100만원 계약서와 1억원 계약서의 해시 값이 같기만 하면 됨

# 어떤 일방향 해시 함수를 사용하면 좋을까

- MD5는 안전하지 않으므로 사용해서는 안된다
- SHA-2는 SHA-1에 대한 공격방법에 대한 대처를 하여 고안해서 안전
- SHA-3는 안전
- 자작 알고리즘은 안됨

# 일방향 해시 함수로 해결할 수 없는 문제

- 일방향 해시 함수는 조작 또는 변경 검출은 가능하나 거짓행세 검출을 못한다
- 인증
  - 이 파일이 정말로 앨리스가 작성한 것인지를 확인하는 것
  - 인증을 수행하기 위한 기술
    - 메시지 인증 코드
    - 디지털 서명

# 정리

- 일방향 해시 함수
  - 임의의 길이의 메시지로부터 공정 길이의 해시 값을 계산
  - 해시 값을 비교하는 것만으로 2개의 메시지가 같은지 판단 가능
  - 메시지 변경 같은 조작 검출에 유효한 기술
  - 조작은 검출 가능하나 거짓행세 검출은 불가능(메시지 인증 코드나 디지털 서명 필요)

# 퀴즈

## 일방향 해시 함수의 기초 지식

- SHA3-512는 임의의 길이 데이터를 512비트로 변환하는 대칭 암호 알고리즘의 일종이다 -> X, 일방향 해시 함수
- 어떤 메시지의 해시 값과 같은 해시 값을 갖는 다른 메시지를 발견해 해는 것은 지극히 곤란하다 -> 애매하다
- 같은 해시 값을 갖는 다른 2개의 메시지를 발견해 내는 것은 지극히 곤란하다 -> 애매하다
- SHA3-512의 해시 값은 64바이트다 -> O, 512비트
- 메시지를 1비트만 변경하면 해시 값도 1비트만 변화한다 -> X

---

# 메시지 인증 코드

## 올바른 송금 의뢰

- 앨리스: 은행 A의 고객
- 밥: 은행 B의 고객
- A은행에 앨리스로부터 송금 의뢰가 도착
- 내용
  - 내 계좌 앨리스-5374에서 B은행의 계좌 밥-6671로 1억원을 송금바랍니다

#### A 은행이 해야할 일

- 메시지 출처: 인증
- 통신 중 내용 변경 유무: 무결성

#### 메시지 인증

메시지가 올바른 송신자로부터 온 것이다라는 성질

## 메시지 인증 코드

- 메시지 인증 코드 MAC (Message Authentication Code): 무결성을 확인하고 메시지에 대한 인증을 위한 코드
- 입력: 메시지, 공유하는 키
- 출력: 고정 비트 길이의 코드

#### 일방향 해시와 메시지 인증 코드

- 일방향 해시: 키를 사용하지 않는다
- 메시지 인증 코드: 키를 사용

## 메시지 인증 코드 적용 순서

- 앨리스와 수신자 A은행: 사전에 키(K) 공유
- 앨리스: 송금 의뢰 메시지(M) 작성 MAC 값(MACK(M))을 계산
- 앨리스: 수신자 A은행르보퉈 송금 의뢰 메시지와 MAC 값 전송
- 수신자 A은행: 수신한 송금 의뢰 메시지를 기초로해서 MAC 값 계산
- 수신자 A은행: 앨리스로부터 수신한 MAC 값과 자신이 계산한 MAC 값을 비교
- 수신자 A은행
  - 인증성공: 2개의 MAC 값이 동일하면 송금 의뢰가 틀림없이 앨리스로부터 온 것이라고 판단
  - 인증실패: 2개의 MAC 값이 동일하지 않으면 앨리스로부터 온 것이 아니라고 판단

## 메시지 인증 코드의 키 배송 문제

- 대칭 암호 때의 키 배송 문제와 같은 문제가 메시지 인증 코드에도 발생
- 키 배송 문제를 해결
  - 공개 키 암호
  - 디피 헬만 키 교환
  - 키 배포 센터
  - 키를 안전한 방법으로 별도로 보내기

# 메시지 인증 코드 이용 예

## SWIFT

- 국제 은행간 통신협회
- 은행과 은행은 SWIFT를 통해서 거래 메시지 교환
- 메시지 인증 코드를 사용

## IPsec

- 인터넷 기반의 통신 프로토콜인 IP에 보안 기능을 첨가한 것
- 통신 내용 인증과 무결성을 위해 메시지 인증 코드를 이용

## SSL/TLS

- 웹에서 온라인 쇼핑을 할 때 사용되는 통신 프로토콜
- 통신 내용의 인증과 무결성 확인을 위해 메시지 인증 코드를 이용

# 메시지 인증 코드의 실현 방법

## 일방향 해시 함수를 이용한 실현

- SHA-1나 MD5와 같은 일방향 해시 함수를 이용하여 메시지 인증 코드를 실현
- HMAC

## 블록 암호를 이용한 실현

- 트리플 DES나 AES와 같은 블록 암호를 사용해서 메시지 인증 코드를 실현
  - 블록 암호 키를 메시지 인증 코드의 공유키로 사용
  - CBC 모드로 메시지 전체를 암호화
  - 메시지 인증 코드에서는 복호화를 할 필요가 없으므로 최종 블록 이외는 폐기
  - 최종 블록을 MAC 값으로 이용

## 그 밖의 방법으로 실현

- 스트림 암호
- 공개 키 암호

# 인증암호

- 인증 암호(AE 혹은 AEAD)
  - 2000년 이후 연구 진행
  - 대칭 암호와 메시지 인증 코드를 조합하여 기밀성.무결성.인증을 동시에 충족시키는 구조
- Encrypt-then-MAC
  - 평문을 대칭 암호로 암호화한 후 암호문의 MAC 값을 계산
  - 메시지 인증 코드 입력에 암호문을 부여
  - 선택 암호문 공격을 막을 수 있다
- Encrypt-and-MAC
  - 평문을 대칭 암호로 암호화하고, 그와는 별도로 평문의 MAC 값을 얻는 방법
- MAC-then-Encrypt
  - 미리 평문의 MAC 값을 얻고, 평문과 MAC 값 양쪽을 정리하여 대칭 암호로 암호화하는 방법

## GCM과 GMAC

- GCM (Galios/Counter Mode)
  - 인증 모드의 일종
  - AES와 같은 182비트 블록 암호를 CTR 모드로 이용하여 MAC 값을 얻기 위해 덧셈과 곱셈을 반복하는 해시 함수를 사용
  - CTR 모드는 1씩 늘어가는 숫자를 암호화하기 때문에 각 블록을 병렬 처리하여 실행속도를 높일 수가 있음
  - CTR 모드와 MAC 값 생성에 공통 키를 사용하기 때문에 키 관리도 편리
- GMAC(Galios/Counter Mode MAC)
  - GCM을 메시지 인증 코드 전용으로 사용

# HMAC

- HMAC은 일방향 해시 함수를 이용하여 메시지 인증 코드를 구성하는 방법
- HMAC의 일방향 해시 함수는 모듈형으로 골라서 사용
  - HMAC-SHA1: SHA-1
  - HMAC-SHA224: SHA-224
  - HMAC-SHA256: SHA-256
  - HMAC-SHA384: SHA-384
  - HMAC-SHA512: SHA-512
- 새 표준인 SHA-3 KECCAK을 이용해 HMAC 작성 가능

## 순서

- 키에 대한 패딩
- 패딩한 키와 ipad의 XOR
- 메시지 결합
- 해시 값 계산
- 패딩한 키와 opad의 XOR
- 해시 값과 결합
- 해시 값 계산

# 메시지 인증 코드에 대한 공격

## 재전송 공격

보존해 둔 정당한 MAC 값을 반복해서 송신하는 공격

#### 방어

- 순서 번호
  - 송신 메시지에 매회 1씩 증가하는 번호를 붙이기
  - 마지막 통신 시 순서번호 저장
- 타임스탬프
  - 송신 메시지에 현재 시각 넣기
  - 송수신자 사이의 동기화 필요
- 비표
  - 송신자에게 일회용의 랜덤한 값을 전송
  - 메시지와 비표를 합해 MAC 값을 계산
  - 비표 값은 통신 때마다 교체

## 키 추측 공격

- 메시지 인증 코드에 대한 공격
  - 전사공격
  - 생일공격
- MAC 값만 획득한 공격자가 키를 추측하지 못하도록 해야 한다
  - 해시 함수의 일방향성
  - 해시 함수의 충돌내성
  - 키 생성의 의사난수생성기 사용

# 메시지 인증 코드로 해결할 수 없는 문제

## 제 3자에 대한 증명

- 앨리스로부터 메시지를 받은 밥이 이 메시지는 앨리스가 보낸 것이다라는 것을 제 삼자인 검증자 빅터에게 증명 불가
- 이유
  - 일단 키를 빅터에게 알려줘야
  - 앨리스와 밥 모두가 키를 가지고 있으므로 둘 중 누가 작성했는지 말할 수 없다

## 부인 방지

- 밥이 MAC 값이 딸린 메시지를 받았고 이 메시지는 앨리스로부터 온 것이다 라는 걸 확실히 알 수 있음
- 하지만 앨리스가 전송 자체를 부정할 경우 제3자에게 이 사실을 증명 불가
- 부인
  - 앨리스가 송신자체를 부정
- 메시지 인증 코드로는 부인 방지 불가

# 퀴즈

## 메시지 인증 코드의 기초 지식

- 메시지의 인증 코드를 사용하면 메시지의 기밀성이 지켜진다 (X)
- 메시지의 인증 코드를 사용하면 조작을 검출할 수 있다 (O)
- 메시지의 인증 코드를 사요하려면 송신자와 수신자 사이에 공유하는 키가 필요하다 (O)
- 메시지의 인증 코드를 사용하면 부인 방지를 할 수 있닫 (X)

---

# 디지털 서명

## 앨리스의 차용서

- 차용서를 이메일로 보내면 어떨까
  - 메일을 누군가가 변경했을 수 있다
  - 처음부터 앨리스인 것처럼 거짓 행세를 한 누군가가 보낸 것인지도 모른다
  - 나중에 앨리스가 그런 차용서 난 몰라라고 부인할 수도 있다

## 메시지 인증코드에서 디지털 서명으로

#### 메시지 인증 코드의 한계

- 메시지 인증코드를 사용하면 메시지의 변경과 거짓 행세를 검출할 수 있다
- 메시지 인증 코드는 부인 방지에는 도움이 되지 않는다

#### 디지털 서명을 이용한 해결

- 앨리스가 사용하는 키는 앨리스 만이 알고 있는 개인적인 것
- 앨리스는 메시지 송신 시에 그 개인적인 키를 써서 서명을 작성
- 수신자 밥은 앨리스의 키와는 다른 키를 써서 서명을 검증

#### 디지털 서명

- 공개키 암호방식을 이용한 전자서명의 한 종류
- 전자서명은 송신자가 작성한 전자문서 자체를 암호화하는 것이 아니다
- 그 전자서명에 작성자로 기재된 자가 그 전자문서를 작성하였다는 사실과 작성내용이 송.수신과정에서 위조.변조되지 않았다는 사실을 증면한다
- 작성자가 그 전자문서 작성 사실을 나중에 부인할 수 없게 하는 역할을 한다

## 서명 작성과 서명 검증

- 서명을 작성하는 행위
  - 서명용 키와 검증용 키가 나눠져 있어 검증용 키로 서명을 작성할 수는 없다
- 서명을 검증하는 행위
  - 서명옹 키는 서명을 하는 사람만이 가지고 있지만 검증용 키는 서명을 검증하는 사람이라면 누구라도 가질 수 있다

## 공개 키 암호와 디지털 서명

- 공개 키 암호
  - 암호 키와 복호 키가 나눠져 있어 암호키로 복호화를 행할 수는 없다
  - 복호키는 복호화를 행하는 사람만이 가지고 있지만 암호키는 암호화를 행하는 사람이라면 누구나 가질 수 있다
- 디지털 서명
  - 공개 키 암호를 역으로 사용함으로써 실현
  - 메시지를 개인 키로 암호화 = 서명 작성
  - 암호문을 공개 키로 복호화 = 서명 검증

|              | 개인 키                   | 공개 키                     |
| ------------ | ------------------------- | --------------------------- |
| 공개 키 암호 | 수신자 복호화             | 송신자 암호화               |
| 디지털 서명  | 서명자가 서명 작성에 사용 | 검증자들이 서명 검증에 사용 |
| 키 보관      | 개인이 가짐               | 필요한 사람은 아무나 가짐   |

# 디지털 서명 방법

## 메시지에 직접 서명하는 방법

- 앨리스는 자신의 개인 키로 메시지를 암호화
- 앨리스는 메시지와 서명을 밥에게 송신
- 밥은 수신한 서명을 앨리스의 공개 키로 복호화
- 밥은 이제 서명을 복호화해서 얻어진 메시지와 앨리스로부터 직접 수신한 메시지를 비교한다

## 메시지의 해시 값에 서명하는 방법

- 앨리스는 일방향 해시 함수로 메시지의 해시 값을 계산
- 앨리스는 자신의 개인 키로 해시 값을 암호화
- 앨리스는 메시지와 서명을 밥에게 송신
- 밥은 수신한 서명을 앨리스의 공개 키로 복호화
- 밥은 수신한 서명으로부터 얻어진 해시 값과 앨리스로부터 직접 수신한 메시지의 해시 값 비교

# 디지털 서명에 대한 의문

## 암호문이 왜 서명으로서 사용 가능한 것인가

- 개인 키로 암호화한다는 것은 행하고 있는 처리의 내용을 설명한 것이지, 여기에서는 기밀성을 실현하기 위해 암호화하고 있는 것은 아니다
- 인증자
  - 키를 가지고 있는 사람만이 만들 수 있는 정보

## 기밀성을 유지할 수 없는 것은 아닐까

- 맞다. 디지털 서명은 기밀성을 지키기 위한 것은 아니다
- 만약 기밀성이 필요하다면 메시지를 그대로 보내는 것이 아니고 암호화를 별도로 행해서 보내야 된다

## 복사된 서명이 만들어지는 것은 아닐까

- 통상의 파일 복사처럼 서명도 복사본을 간단히 만들 수 있다
- 하지만, 서명 복사를 만들 수 있다고 해서 서명이 무의미해지는 것은 아니다
  - 복사한 데이터가 표현하고 있는 것은 특정의 서명자가 특정의 메시지에 대해서 서명했다고 하는 것뿐이기 때문
  - 복사해도 서명자는 바뀌지 않고 메시지의 내용도 바뀌지 않는다

#### 복사된 서명

- 특정 서명자와 특정 메시지가 결부되어 있다는 사실이 중요
- 아무리 복사를 해도 그 메시지에 누가 서명했는가하는 사실에는 조금도 변화가 없다
- 복사는 할 수 있다. 그러나 그것에 의해 서명이 무의미해지는 것은 아니다

## 서명 변경이 가능한 것은 아닐까

- 확실히 서명한 후에 메시지와 서명의 내용을 수정할 수는 있다. 그러나 수정해버리면 서명의 검증에 실패하기 때문에 검증하는 사람은 수정이 행해졌다는 것을 검출할 수 있다
- 서명 대상의 메시지와 서명 양쪽을 수정해서 서명의 검증에 성공할 수 있도록 앞뒤를 잘 맞출 수 있지는 않을까
  - 아니다. 그것은 사실상 불가능하다

## 서명만 재이용할 수 있는 것은 아닐까

- 확실히 서명 부분만을 잘라내서 다른 메시지에 첨부하는 것은 가능하다
- 그러나 서명의 검증에는 실패한다

## 서명을 삭제하더라도 계약파기를 할 수 없는 것은 아닌가

- 분명히 디지털 서명이 붙은 차용서는 삭제해도 파기할 수 없다
- 디지털 서명이 붙은 차용서를 파기하는 경우에는 영수증에 상당하는 문서를 새로 만들고, 그것에 대해 상대에게 디지털 서명을 부탁해야 한다

## 어떻게 해서 부인 방지가 되는 것인가

- 디지털 서명의 경우 서명을 작성할 수 있는 키(개인 키)는 송신자만 가지고 있다. 그러므로 서명을 작성할 수 있는 것은 송신자뿐이다
- 그렇기에 송신자는 그 서명을 작성한 것은 내가 아니다라고 주장할 수가 없다

## 디지털 서명은 정말로 종이 서명 대용이 되는 것일까

- 한국에서는 1999년 전자서명법이 제정, 시행
- 이 법률들은 전자적으로 실현된 서명을 날인이나 손으로 쓴 서명과 같이 취급하기 위한 법적인 근거
- 그러나 실제는 디지털 서명에 관한 분쟁이 발생하여 디지털 서명의 유효성을 둘러싸고 재판이 일어날 가능성은 충분히 생각할 수 있다

# 디지털 서명 활용 예

## 보안 공지

- 클리어 서명
  - 메시지를 암호화하지 않고 서명만 한 것

## 소프트웨어 다운로드

- 소프트웨어의 작성자가 소프트웨어에 디지털 서명 작성
- 사용자는 다운로드한 후 서명 검증
- 적극적 공격자에 의한 내용 조작을 검출하는 것이 가능

## 공개 키 인증서

- 디지털 서명을 검증
  - 올바른 공개 키가 필요
- 자신이 입수한 공개 키가 바른 공개 키인지 어떤지를 검증하기
- 공개 키 인증서
  - 공개 키를 메시지로 간주하고 그것에 디지털 서명을 한 것
  - 공개 키에 디지털 서명을 붙인 것

## SSL/TLS

- 서버가 올바른 것이라는 것을 인증 위해 서버 인증서 이용
- 서버 공개 키에 디지털 서명한 것

# RSA에 의한 디지털 서명

## RSA에 의한 서명 작성

- 서명 = (메시지)D mod N
- D와 N은 서명자의 개인 키

## RSA에 의한 서명 검증

- 서명으로부터 얻어진 메시지 = (서명)E mod N
- E와 N은 서명자의 공개 키

## 자세한 RSA 서명

- 공개 키: E = 5, N = 323
- 개인 키: D = 29, N = 323
- N이 323이므로 메시지는 0 ~ 322 범위의 정수에서 고른다
- 여기서는 123이라는 메시지에 서명을 해보자

#### 서명 작성

- 메시지D mod N = 123의 29승 mod 323 = 157
- 서명은 157
- 수신자에게 전달할 것
  - (메시지, 서명) = (123, 157)

#### 서명 검증

- (메시지, 서명) = (123, 157) 수신
- 공개 키(E, N) = (5, 323)을 사용해서 서명으로부터 얻어진 메시지를 계산
- 서명E mod N = 157의 5승 mod 323 = 123
- 이 메시지 123은 분명히 송신자가 보낸 메시지 123과 일치
- 서명 검증에 성공

# 기타 디지털 서명

## ElGamal 방식

- Taher ElGamal에 의한 공개 키 알고리즘으로 mod N으로 이산 대수를 구하는 것이 곤란하다는 것을 이용
- ElGamal 방식은 공개 키 암호와 디지털 서명에 이용
- 암호 소프트웨어 GnuPG에서도 알고리즘의 하나로 사용

## DSA

- 디지털 서명 알고리즘의 일종으로 NIST가 1991년에 제정한 디지털 서명 규격
- DSA는 Schnorr의 알고리즘과 ElGamal 방식의 변종으로 디지털 서명에만 이용

## ECDSA

타원 곡선 암호(ECC)를 사용한 디지털 서명 알고리즘

## Rabin 방식

- M. O. Rabin에 의한 공개 키 알고리즘으로 mod N으로 평방근을 구하는 것이 곤란하다는 것을 이용
- Rabin 방식은 공개 키 암호와 디지털 서명에 이용

# 디지털 서명에 대한 공격

## 중간자 공격

- 디지털 서명에도 위협이 되는 공격
- 중간자 공격을 막으려면 입수한 공개 키가 정확한 상대의 것인지 아닌지를 확인 필요
- 핑거프린트
  - 공개 키를 취급하는 소프트웨어에서 공개 키의 해시 값을 표시하는 수단
  - 이 해시 값을 핑거프린트라 한다

## 일방향 해시 함수에 대한 공격

- 디지털 서명에서 사용하는 일방향 해시 함수는 충돌 내성을 가져야만 한다
- 만약 충돌내성이 없으면 디지털 서명을 한 해시 값과 같은 해시 값을 갖는 다른 메시지를 만들 수 있다

## 디지털 서명을 사용한 공개 키 암호 공격

- 밥은 맬로리한테 온 메일을 읽고 첨부 데이터를 보니 확실히 랜덤한 데이터인 것 같다고 여긴다 (하지만 실은 이것은 앨리스가 밥의 공개 키로 암호화한 암호문이다)
- 밥은 순수한 마음으로 첨부 데이터에 서명을 한다

#### 맬로리의 목적 달성

- 서명 = (첨부데이터)D mod N (RSA의 서명 작성)
- = (암호문)D mod N (첨부 데이터는 실은 암호문이기 때문에)
- = 메시지 (복호화 처리가 행하여졌기 때문에)

> 의미를 모르는 메시지는 절대로 디지털 서명을 하지 않아야

## 잠재적 위조

- 개인 키가 없는 공격자가 의미가 있는 메시지를 만들고 그에 대한 바른 디지털 서명을 만들 수 있다면 그 디지털 서명 알고리즘은 안전하지 않음
- 의미가 없는 메시지(예, 랜덤한 비트 열)라고 하더라도, 만약 올바른 디지털 서명을 만들 수 있다면 (즉, 검증을 통과할 수 있는 디지털 서명이 된다면), 그것은 디지털 서명 알고리즘에 대한 위협

#### RSA에서의 잠재적 위조

- 메시지를 RSA로 복호화하는 디지털 서명 알고리즘에서는 잠재적 위조가 가능
  - 랜덤한 비트 열 S를 RSA의 공개 키로 암호화한 것을 M이라고 하면, S가 M의 바른 디지털 서명이 되어 버리기 때문 (이것은 앞절에서 설명한 것의 역이다)
  - 공개 키는 공격자도 구할 수 있으므로 디지털 서명의 잠재적 위조가 가능
- 대처법
  - RSA-PSS
    - RSA를 개량함
    - 메시지에 대해서가 아니라 메시지의 해시 값에 대해 서명하는 방법
    - 해시 값의 계산 시에는 메시지에 솔트를 더해 더욱 안전성 향상

## 기타 공격

- 공개 키 암호에 대한 공격의 대부분은 디지털 서명에 대한 공격으로서도 사용 가능
- 개인 키에 대한 전사 공격
- RSA의 N을 소인수분해하는 공격

# 기타 기술과 비교

## 메시지 인증 코드와 디지털 서명

- 메시지 인증 코드와 디지털 서명은 매우 유사한 기술
- 두 가지 모두 무결성 확인을 통해 인증이 가능

|              | 대칭 암호        | 공개 키 암호                             |
| ------------ | ---------------- | ---------------------------------------- |
| 송신자       | 공유 키로 암호화 | 공개 키로 암호화                         |
| 수신자       | 공유 키로 복호화 | 개인 키로 복호화                         |
| 키 배송 문제 | 발생한다         | 발생하지만, 공개 키의 인증이 별도로 필요 |
| 기밀성       | O                | O                                        |

|              | 메시지 인증 코드        | 디지털 서명                              |
| ------------ | ----------------------- | ---------------------------------------- |
| 송신자       | 공유 키로 MAC 값을 계산 | 개인 키로 서명을 작성                    |
| 수신자       | 공유 키로 MAC 값을 계산 | 공개 키로 서명을 검증                    |
| 키 배송 문제 | 발생한다                | 발생하지만, 공개 키의 인증이 별도로 필요 |
| 무결성       | O                       | O                                        |
| 인증         | O(통신 상대에 대해서만) | O(제 3자에 대해서도)                     |
| 부인방지     | X                       | O                                        |

## 하이브리드 암호 시스템과 해시 값에 대한 디지털 서명

- 대칭 암호의 키는 기밀성의 핵심
- 일방향 해시 함수의 해시 값은 무결성의 핵심

# 디지털 서명으로 해결할 수 없는 문제

- 조작되어 있지 않은 공개 키를 거짓 행세 하고 있지 않은 송신자로부터 받을 필요가 있다
- 인증서
  - 바른 공개 키를 입수하기 위해 고안된 것이 공개 키 기반(Public Key Infrastructure)
  - 공개 키 암호 및 디지털 서명의 기술을 사회적인 기반(기반 구조)으로 만들어 가는 것

## 기술적인 방법만으로는 해결할 수 없는 문제

- 의문: 공개된 장소에서 구한 앨리스의 공개 키는 믿을만한 것인가
- 해결책: 제 3자가 자신의 개인 키로 앨리스의 공개 키를 서명해서 밥에게 전달한다
  - 의문: 제 3자는 믿을 수 있는가
  - 해결책: 송신자 앨리스와 수신자의 밥은 둘이 믿을 수 있는 제3자를 선정한다

# 퀴즈

## 공개 키와 개인 키의 역할

- 앨리스가 메시지의 디지털 서명을 작성하려면 앨리스와 공개 키와 개인 키 중 어느 쪽이 필요한가? 개인 키
- 앨리스의 서명을 검증하기 위해서는 앨리스의 공개 키와 개인 키 중 어느 쪽이 필요한가? 공개 키

## 디지털 서명의 기초 지식

- 디지털 서명을 검증하기 위해서는 서명한 사람의 개인 키가 필요하다 (X) -> 공개키 (교재 고치기)
- RSA는 디지털 서명 알고리즘을 사용할 수 있다 (O)
- 디지털 서명을 사용하면 메시지의 기밀성을 지킬 수 있기 때문에 도청당할 염려가 없다 (X) -> 기밀성을 지키는 것이 아니라 부인 방지

---

# 인증서

## 인증서란 무엇인가

- 공개 키 인증서
- 이름이나 소속, 메일 주소 등의 개인 정보
- 당사자의 공개 키가 기재됨
- 인증기관의 개인 키로 디지털 서명

## 인증서를 사용하는 시나리오

- 밥이 키 쌍을 작성한다
- 밥은 인증기관 트렌트에 자신의 공개 키를 등록한다
- 인증기관 트렌트는 밥의 공개 키에 자신의 개인 키로 디지털 서명을 해서 인증서를 작성한다
- 앨리스는 인증기관 트렌트의 디지털 서명이 되어 있는 밥의 공개 키(인증서)를 입수한다
- 앨리스는 인증기관 트렌트의 공개 키를 사용해서 디지털 서명을 검증하고 밥의 공개 키가 맞다는 것을 확인한다
- 앨리스는 밥의 공개 키로 메시지를 암호화해서 밥에게 송신한다
- 밥은 암호문을 자신의 개인 키로 복호화해서 앨리스의 메시지를 읽는다

# 공인 인증서 (인증서 만들기)

## 공인 인증서 종류

- 범용 공인인증서
  - 모든 분야에서 이용
  - 인터넷뱅킹, 온라인증권, 전자상거래, 전자정부 민원서비스, 4대 사회보험, 국세청 홈택스, 전자세금계산서, 전자입찰/조달, 온라인교육, 예비군 등 다양한 분야 활용
  - 소정의 수수료
- 용도제한 공인인증서
  - 은행 및 보험, 신용카드 업무, 정부 민원 업무 등 특정 분야에서만 이용
  - 해당 기관이 고객에게만 발급
  - 무료

## 인증서 표준 규격

- X.509
  - 공개 키 인증서와 인증 알고리즘 표준 공개 키 기반(PKI)의 ITU-T의 표준
  - 가장 널리 사용
  - ITU나 ISO에서 규정한 규격
  - 인증서 생성.교환을 수행할 때 사용
  - 많은 애플리케이션에서 지원

# 공개 키 기반 구조(PKI)

## 공개 키 기반

- 공개 키를 효과적으로 운용하기 위해 정한 많은 규격이나 선택 사양의 총칭
  - PKCS
    - RSA사가 정하고 있는 규격의 집합
  - RFC 중에서도 PKI에 관련된 문서
    - 인터넷의 선택사양을 정함
  - X.509
  - API 사양서

## PKI 구성 요소

- 이용자 - PKI를 이용하는 사람 (개체)
  - PKI를 사용해서 자신의 공개 키를 등록하고 싶어하는 사람
  - 등록되어 있는 공개 키를 사용하고 싶어하는 사람
  - 하는 일
    - 키 쌍을 작성(인증기관이 작성하는 경우도 있다)
    - 인증기관에 공개 키를 등록
    - 인증기관으로부터 인증서를 발행 받음
    - 필요할 경우 인증기관에 신청해서 등록한 공개 키를 무효로 한다
    - 수신한 암호문을 복호화한다
    - 메시지에 디지털 서명을 한다
  - 공개 키 사용자가 하는 일
    - 메시지를 암호화해서 수신자에게 송신한다
    - 디지털 서명을 검증한다
- 인증기관 - 인증서를 발행하는 사람
  - 인증서의 관리를 행하는 기관
  - 키 쌍을 작성한다(이용자가 작성하는 경우도 있다)
  - 공개 키 등록 때 본인을 인증한다
  - 인증서를 작성해서 발행한다
  - 인증서를 폐지한다
  - 등록 기관
    - 인증기관의 일 중 공개키의 등록과 본인에 대한 인증을 대행하는 기관
- 저장소 - 인증서를 보관하고 있는 DB
  - 인증서를 보존
  - PKI 이용자가 인증서를 입수할 수 있도록 한 데이터베이스
  - 인증서 디렉토리

## 공인 인증기관

- 미래창조과학부 산하 민간 최상위 인증기관인 한국인터넷진흥원이 있음
- 전자서명법 제 4조의 규정에 의해 지정된 공인인증기관은 5개가 있음
- 개인 또는 기업 등의 요청에 따라 공인인증서를 발급
  - 철저한 심사 젗라를 통해 발급
  - 법적 효력과 안전성 보장

## 역할

- 키 쌍의 생성
- 인증서 등록
- 인증서 폐지와 CRL

#### 키 쌍의 생성

- PKI의 이용자가 생성하기
- 인증기관이 생성하기
  - 개인 키를 이용자에게 보내는 추가 업무
  - 방법은 RFC 7292 규격으로 정함

#### 인증서 등록

- 이용자는 인증기관에 인증서 작성을 의뢰
  - 규격은 RFC 2986 등으로 정함
- 운용 규격에 근거해서 이용자를 인증하고, 인증서를 생성
  - 인증 기관의 개인 키를 사용해서 디지털 서명을 함
  - 인증서 형식을 X.509로 정함

#### 인증서 폐지와 CRL

- 폐지해야 할 경우
  - 개인 키 분실 혹은 도난
- 인증서 폐지 목록(CRL)을 작성
- 인증기관 최신 CRL 조사해서 그 인증서 유효성 확인 필요

## 계층 구조를 갖는 인증서

- 루트 CA: 최상위 인증기관
- 셀프 서명: 자기 자신의 공개 키에 대해서 자신의 개인 키로 서명하는 디지털 서명

## 다양한 PKI

- 누구나 인증기관이 될 수 있고 실제로 세계에는 무수히 많은 인증기관이 존재
- 사내 이용방법
  - 인증기관의 계층을 회사의 조직 계층의 적용
  - 부서별로 PKI 운영하고 상호 인증
- 우리나라 PKI
  - 한국인터넷진흥원 전자서명인증관리센터에서 관리
  - 인증기관의 계층이나, 운용 규약, 공개 키의 등록.인증서 발행 등을 규정

# 인증서에 대한 공격

## 공개 키 등록 이전 공격

- 인증기관이 디지털 서명을 수행하기 이전에 적극적 공격자 맬로리가 공개 키를 자신의 것과 살짝 바꿔치기
- 인증기관은 밥의 정보와 맬로리의 공개 키의 조합에 대해 디지털 서명을 하게 된다

## 닮은 사람을 등록하는 공격

- 오인하기 쉬운 사용자 정보를 사용
  - Name = Bob -> Name = BOB
- 이 공개 키 이름은 BOB로 되어 있지만 맬로리의 공개 키
- 맬로리는 밥의 행세를 하며 Name = BOB으로 되어 있는 인증서를 앨리스에게 보낸다

## 인증 기관의 개인 키를 훔쳐내는 방법

인증기관의 개인 키가 도난당했다면 인증기관은 자신의 키가 도난당했다는 것을 CRL을 사용해서 이용자에게 통지

## 공격자 자신이 인증 기관이 되는 공격

- 맬로리 자신이 인증기관이 된다
- 인증기관이 된 맬로니는 자신의 공개 키라도 이것은 밥의 공개 키이다라고 주장하는 인증서를 자유롭게 발행
- 인증기관을 신뢰할 수 없으면 인증서가 아무리 바르더라도 그 공개키를 사용해서는 안된다

## CRL의 허점을 찌르는 공격 (1)

- 공격자 맬로리는 CRL이 도착하기 전에 빠른 공격을 시도
- 방어 방법
  - 공개 키가 무효가 되면 가능한 한 빨리 인증기관에 전한다 (밥)
  - CRL은 신속하게 발행한다 (트렌트)
  - CRL은 정확히 갱신한다 (앨리스)
  - 공개 키를 이용하기 전에는 공개 키가 무효되지 않았나를 재확인한다 (앨리스)

## CRL의 허점을 찌르는 공격 (2)

- 밥이 앨리스로부터 돈을 뜯어낼 계획 수립
- 밥은 가명을 써서 계좌 X-5897 개설
- 앨리스에게 송금요청을 하고 자신의 서명을 붙임
- 트렌트에게 개인 키가 도난 당했다고 보고
- 앨리스에게 CRL이 도착하기 전 앨리스가 해당 금액을 계좌 X-5897로 송금을 했다면
- 밥은 예금을 인출한다
- 앨리스가 나중에 CRL을 받고 밥에게 항의
- 밥은 자신의 개인 키가 도난 당했다고 주장하고 돈을 착복

## Superfish

- 레노보 사 중대한 사건
  - 컴퓨터에 프리인스톨 되어있던 슈퍼피시라는 애드웨어가 보안 상 문제 일으킴
  - 통신을 가로채 개인 정보를 수집하여 사용자의 인터넷 이용 맞춤 광고를 내보내는 소프트웨어
  - 루트 인증서를 인스톨하여 웹사이트와 웹브라우저 사이에 들어간 후 방문한 웹사이트 인증서를 바꿔치기 하여 웹브라우저에 제시
  - 전형적인 중간자 공격으로 통신 갈취

# 인증서에 대한 Q&A

## 인증서의 필요성

- 의문: 인증기관의 인증서를 사용해서 공개 키를 입수하는 것과 공개 키만을 받는 것과는 같은 것이 아닌가?
- 답
  - 신뢰할 수 없는 경로로 공개 키를 입수하는 경우 중간자 공격이 가능해진다
  - 인증기관으로부터 인증서를 입수하면 중간자 공격의 가능성을 줄일 수 있다

#### 필요성

- 신뢰할 수 있는 공개 키를 입수할 수 있다면 인증기관은 불필요하다
- 신뢰할 수 있는 인증기관의 공개 키를 가지고 있고 인증기관의 본인 확인을 신뢰한다면 그 인증기관이 발행한 인증서에 의해 입수한 공개 키는 신용할 수 있다

## 독자적인 인증 방법을 사용하는 것이 안전한 것이 아닌가

- 의문: 인증서 형식이든 PKI든 공개되어 있는 기술을 사용 하는 것에 불안을 느낀다. 공개되어 있는 기술을 사용한 다는 것은 공격자에게 공격을 위한 정보를 제공하는 것 이 된다고 생각한다. 그것보다는 사내에서 독자적으로 개발한 비밀 인증 방법을 사용하는 편이 안전하지 않을까?
- 답
  - 아니다
  - 비밀 인증 방법을 독자 개발하는 것은 감추는 것에 의한 보안이라는 전형적인 잘못

## 인증기관을 어떻게 신뢰할 것인가

- 의문: 인증기관의 기능은 대강 이해를 했지만, 결국 맴도 는 것 같은 느낌이 든다. 공개 키를 신뢰하기 위해서는 인 증서를 발행한 인증기관을 신뢰해야 하는데, 그렇다면 인 증기관은 어떻게 신뢰하는 것일까?
- 답
  - 이 의문은 정당
  - 이 의문은 신뢰가 어떻게 형성되는가 하는 본질적 문제와 관계되어 있다 (은행에 돈을 맡기는 것 처럼)

# 퀴즈

## 인증기관은 대단히 바쁘다?

디지털 서명이 되어있는 메일을 받을 때마다 인증기관 트렌트에게 디지털 서명의 검증을 받지 않으면 안되니까 바쁠까?

> 잘못됨. 개개의 메일에 있는 디지털 서명을 검증하는 것은 인증기관이 아니라 공개 키의 이용자이기 때문에. 인증기관이라는 것은 인증서 발행기관이라고 부르는 편이 맞다

## 인증서의 기초 지식

- 인증서는 이용자의 공개 키를 인증기관이 암호화한 것 (X) -> 디지털 서명
- 인증서에 포함되어 있는 공개 키가 바른지 어떤지를 확인하기 위해서는 인증기관의 공개 키가 필요하다 (O)
- 전 세계에서 발행되고 있는 인증서는 모두 인증기관의 계층을 따라가면 유일한 루트 CA까지 도달한다 (X) -> 인증기관이 여러 개
- 자신의 개인 키가 누설되었다는 것을 안 이용자는 공개 키를 등록하고 있는 인증기관에 서둘러 연락할 필요가 있다 (O)
- 이용자는 인증기관으로부터 정기적으로 CRL을 입수할 필요가 있다 (O)

# 추가

## 공인인증서 폐지

- 공인 인증서 사라짐
- 지난 5월 20일 국회에서 공인인증서와 사설인증서의 구별을 없애는 내용의 전자서명법 개정안 통과

## 앞으로 인증은

- 기존에 사용하던 공인인증서는 계속 사용 가능
- 공인으로 취급되던 5개 기관이 발급한 인증서와 민간에서 발급한 인증서가 경쟁을 시작하는 것
- 이미 시장에서는 카카오, 네이버, 이통3사가 개발한 인증서가 경쟁
- 공인인증서도 편리해짐 (갱신기간 1년 -> 3년으로 연장)

---

# 13주차. 키

# 키란

## 키는 대단히 큰 수

- 암호 기술을 사용하려면 반드시 키라 불리는 대단히 큰 수가 필요
- 중요한 것은 수 그 자체의 크기라기 보다 키 공간의 크기
- 키 공간의 크기는 키의 비트 길이로 결정

#### 암호별 키 길이

- DES: 56비트
- 3DES
  - DES-EDE2: 112비트
  - DES-EDE3: 168비트
- AES: 128, 192, 256
- RSA: 1024, 2046

## 키는 평문과 동일한 가치를 갖는다

- 키는 평문과 같은 가치
  - 도청자 이브에게 키가 넘어가는 것은 평문이 넘어가는 것과 같은 것

## 암호 알고리즘과 키

- 암호의 기본 상식
  - 검증된 암호 알고리즘을 사용
  - 정보의 기밀성은 암호 알고리즘을 비밀로 하는 것이 아님
  - 키를 비밀로 하는 것에 의해 기밀성이 지켜져야 함

# 다양한 키

## 대칭 암호 키와 공개 키 암호 키

#### 대칭 암호

- 키는 송신자와 수신자만 공유
- 양측이 공유 키를 비밀로 유지

#### 공개 키 암호

- 암호화와 복호화에서 다른 키 사용
- 개인 키를 비밀로 유지

## 메시지 인증 코드 키와 디지털 서명 키

- 메시지 인증 코드
  - 송신자와 수신자가 공통의 키를 사용해서 인증을 수행
- 디지털 서명
  - 서명 작성과 서명 검증에 서로 다른 키를 사용

## 기밀성을 위한 키와 인증을 위한 키

- 보안 속성에 따른 분류
  - 기밀성을 유지하기 위한 키
    - 대칭 암호나 공개 키 암호에서 사용하는 키
    - 복호화키를 모르면 복호 불가
  - 인증을 수행하기 위한 키
    - 메시지 인증 코드나 디지털 서명에서 사용하는 키
    - 키를 모르면 데이터 변경이나 위장 불가

## 세션 키와 마스터 키

- 키 사용 횟수에 따른 분류
  - 세션 키
    - 통신 때마다 한 번만 사용되는 키
  - 마스터 키
    - 반복적으로 사용되는 키

# 컨텐츠 암호화 키와 키 암호화 키

- 키를 사용할 때 암호화 대상에 따른 분류
  - CEK(Contents Encrypting Key)
    - 정보가 암호화의 대상
  - KEK(Key Encrypting Key)
    - 키가 암호화의 대상

# 키 관리

## 키 생성

- 난수를 이용한 키 생성
- 패스워드를 이용한 키 생성

#### 난수 이용한 키 생성

- 난수 사용
  - 이용: 키 성질로 다른 사람이 추측하기 어려워야 한다를 가져야하기 때문
  - 난수는 추측하기 어렵기에 키로 적합
- 난수 생성
  - 하드웨어를 사용하는 것이 좋다
  - 통상적으로 암호용으로 설계된 의사난수 생성기 소프트웨어를 사용
    - 자신이 적당한 바이트 열을 만들면 안됨: 스스로 랜덤한 값이라고 생성해도 인위적인 편중이 있기에
    - 반드시 암호용으로 설계되어 있는 것을 선택해야: 암호용으로 설계 안되어있으면 예측 불가능 성질을 가지고 있지 않음

#### 패스워드

- 패스워드 or 패스 프레이즈로부터 키를 만드는 경우
- 패스 프레이즈라는 것은 복수의 단어로 이러우지는 긴 패스워드
- 패스워드를 키로 직접 이용하지 않고 패스워드를 일방향 해시 함수에 입력해서 얻어진 해시 값을 키로 이용
- PBE와 솔트
  - Password Base Encryption
  - 솔트라 불리는 난수를 부가해 일방향 해시 함수에 입력하고 그 출력을 키로 사용
  - 사전 공격을 막기 위한 조치

## 키 배송

- 키를 사전에 공유하는 방법
- 키 배포센터를 이용하는 방법
- 공개 키 암호를 사용하는 방법
- 또 다른 방법: Diffie-Hellman 키 교환

## 키 갱신

- 공통 키를 사용하여 통신을 하고 있는 중에 정기적으로 키를 교환해가는 방법
- 송신자와 수신자가 동시에 같은 방법으로 키를 교환해야만 함
- 현재 키의 해시 값을 다음 키로 사용

#### 장점

- 키 노출 시 과거 통신의 복호화를 막을 수 있다
  - 백워드 시큐리티라 한다

## 키 보존

- 키 반복해서 사용할 경우 키 저장 문제를 고려
  - 키 기억
    - 보통 실용적 크기나 비트화된 표현 등으로 기억할 수 없다
  - 키 암호화
    - 키를 암호문과 동일한 컴퓨터 내에 두는 것은 어리석은 짓
    - 파일 형태로 보존된 키를 금고 등의 안전한 장소에 보관한다 (공간적 제약)
    - 키를 암호화해서 저장하는 기술을 사용

#### 키를 암호화 하는 키

- KEK
  - 키를 암호화 하는 키
  - 다수의 키를 한 개의 키(KEK)로 암호화하여 보관

## 키 폐기

- 왜 키를 버리지 않으면 안될까
  - 불필요해진 키는 확실히 삭제
- 어떻게 버리는 것인가
  - 암호 소프트웨어 뿐만 아니라 컴퓨터 전체가 보안을 염두에 둔 설계를 바탕으로 만들어져 있어야 함
- 키를 잃어버리면?
  - 대칭 암호 공유 키 분실: 암호문을 복호화 할 수 없음
  - 메시지 인증 코드 키: 자신이 자신이라는 것을 인증시킬 수 없다
  - 공개 키 암호의 개인 키 분실: 공개 키 암호의 암호문을 복호화 할 수 없다

# Diffie-Hellman(디피-헬먼) 키 교환

## 디피 헬먼 키 교환

- 1976년 디피와 헬먼이 발명한 알고리즘
- 타인에게 알려져도 상관없는 정보를 두 사람이 교환하는 것만으로 공통의 비밀 값을 만들어내는 방법
- IPsec에서는 디피헬만 키 교환을 개량한 방법을 사용

## 절차

- 앨리스는 밥에게 2개의 소수 P와 한 원시근 G를 송신
- 앨리스는 난수 A를 준비
- 밥은 난수 B를 준비
- 앨리스는 밥에게 GA mod P라는 수를 송신
- 밥은 앨리스에게 GB mod P라는 수를 송신
- 앨리스는 밥이 보낸 수를 A제곱해서 mod P를 계산
  - 앨리스가 계산한 키 = (GB mod P)A mod P = GB\*A mod P
- 밥은 앨리스가 보낸 수를 B제곱해서 mod P를 계산
  - 밥이 계산한 키 = (GA mod P)B mod P = GA\*B mod P

## 이브는 키를 계산할 수 없는 것일까

- 공격자 이브가 알 수 있는 것
  - P, G, GA mod P, GB mod P라는 4개의 수
- 이 4개의 수로부터 앨리스와 밥이 공유한 키(GA\*B mod P)를 계산하는 것은 수학적으로 난해
- 유한체 상의 이산대수 문제
  - GA mod P로부터 수 A를 효율적으로 계산하는 알고리즘은 아직 없음

#### 안전성

- 유한체 상의 이산대수문제를 풀기 어렵기 때문에 디피헬만 키 교환의 안전성이 보장됨
- 단 소수 P가 적당히 커야하고, 양측이 선택하는 수도 랜덤해야

## 원시근의 의미

- GA mod P (P=13인 경우)
  - 2, 6, 7, 11이 원시근 계산한 값을 집합으로 했을 때 다 다른 값
  - 2는 13의 원시근

## 구체적 키 교환의 예

- 앨리스는 밥에게 2개의 수 P=13과 G=2를 송신
- 앨리스는 랜던함 수 A=9를 준비
- 밥은 랜덤한 수 B=7을 준비
- 앨리스는 밥에게 GA mod P = 2의 9승 mod 13 = 5를 송신
- 밥은 앨리스에게 GB mod P = 2의 7승 mod 13 = 11을 송신
- 앨리스는 밥이 보내온 수 11을 A 제곱해서 P로 mod를 계산
  - 앨리스가 계산한 키 = (GB mod P)A mod P
  - = 11A mod P
  - = 11의 9승 mod 13
  - 8
- 밥은 앨리스가 보내 온 수 5를 B 제곱해서 P로 mod를 계산
  - 밥이 계산한 키 = (GA mod P)B mod P
  - = 5B mod P
  - = 5의 7승 mod 13
  - 8

## 타원 곡선 디피 헬만 키 교환

- 디피 헬만 키 교환에서는 이산대수 문제를 풀기가 매우 어렵다는 사실 이용해서 키 교환 실현
- 이산대수 문제를 타원곡선상의 이산대수 문제로 대체한 키 교환 알고리즘
- 디피 헬만 키 교환보다 짧은 키 길이로 높은 보안성 실현

# 패스워드를 기초로 한 암호 (PBE)

## 패스워드를 기초로 한 암호란

- 패스워드를 기초로 한 암호
  - 패스워드를 기초로 해서 만든 키로 암호화를 수행하는 방법
  - RSA사의 PKCS #5 규격으로 규정되어 있는 PBE는 Java의 java.crypto 패키지 등에 내장
  - 암호 소프트웨어 PGP에서 키를 보존

#### 절차

- 중요한 메시지의 기밀성을 유지하고 싶다
- 메시지를 그대로 디스크에 보존하면 누군가에게 읽혀질 수도 있다
- 키(CEK)를 사용해서 메시지를 암호화하자
- 하지만 이번에는 키(CEK)의 기밀성을 유지해야한다
- 키(CEK)를 그대로 디스크에 보존하는 것은 위험하다
- 다른 키(KEK)를 사용해서 키(CEK)를 암호화하자
- 그렇지만 이번에는 키(KEK)의 기밀성을 유지해야
- 그럼 키(KEK)는 패스워드로부터 만들기로하자
- 패스워드만 만들면 사전 공격을 받을 위험이 있다
- 그렇다면 키(KEK)는 솔트와 패스워드로부터 만들기로 하자
- 솔트는 암호화한 키(CEK)와 함께 보존하고 키(KEK)는 버리기로 하자
- 패스워드는 자신의 머릿속에 보존해두기로 하자

## 암호화

- KEK 생성
  - 의사난수 생성기로 솔트라는 난수 생성
  - 솔트와 앨리스가 입력한 패스워드를 순서대로 일방향 해시함수에 입력
  - 얻어진 해시 값이 키의 암호화를 위한 키(KEK)
- 세션 키 생성과 암호화
  - 의사난수 생성기를 사용해서 세션 키를 생성
  - KEK를 사용해서 암호화하고, 솔트와 함께 안전한 장소에 보존
  - 세션 키의 암호화가 끝나면 KEK는 폐기
    - 솔트와 패스워드만 있으면 KEK는 복원 가능
- 메시지 암호화
  - 세션 키를 사용해서 메시지를 암호화
  - PBE의 암호화에서 하는 것
    - 솔트
    - KEK로 암호화된 세션 키
    - 세션 키로 암호화된 메시지
  - 솔트와 KEK로 암호화된 세션 키는 안전한 장소에 보관

## 복호화

- KEK 복원
  - 보존해 둔 솔트와 앨리스가 입력한 패스워드를 일방향 해시함수에 순서대로 입력
  - 이것은 KEK를 생성했을 때와 같은 계산이므로 얻어진 해시 값은 KEK
- 세션키 복호화
  - 세션 키 구하기
  - 보존해 둔 KEK로 암호화된 세션 키를 가지고와서 (1)에서 복원시킨 KEK를 사용해서 복호화
- 메시지 복호화
  - 복호화한 세션 키를 사용해서 암호화된 메시지를 복호화

## 솔트 역할

- 의사난수 생성기로 만들어지는 랜덤한 수로 키(KEK)를 만들 때에 패스워드와 함께 일방향 해시 함수에 입력
- 사전 공격을 막기 위해 필요

#### 솔트 미사용 시

- 적극적 공격자 맬로리는 사전 데이터 등을 기초로 해서 KEK의 후보를 미리 대량으로 만들어 두는 것이 가능
- 암호화된 세션 키를 훔친 다음 복호화를 시도하는데, KEK의 후보를 미리 만들어 둠으로써 시행시간을 대폭 단축할 수가 있다

#### 솔트 사용 시

- KEK 후보의 종류 수가 솔트의 비트 길이만큼 늘어나기에 KEK의 후보를 미리 만들어 놓는다는 것이 매우 어려움
- 솔트가 확보되지 않으면 KEK의 후보 생성 불가
- 솔트에 의해 KEK의 후보수가 대폭 증가되기 때문

## 패스워드 역할

- 충분한 비트 수를 갖는 패스워드를 기억할 수는 없다
- PBE에서는 패스워드로 만든 키(KEK)로 세션 키(CEK)를 암호화
- 패스워드로 만든 키(KEK)는 의사난수 생성기로 만든 세션 키(CEK)보다도 약하다
- 튼튼한 금고의 키를 약한 금고에 보관하고 있는 것과 같은 것
- PBE를 이용하려면 솔트와 암호화한 CEK를 물리적으로 지키는 방법을 병행해야
  - CEK를 항상 휴대 중인 IC 카드에 보관

## 스트레칭에 의한 PBE 개선

- 스트레칭
  - 일방향 해시함수 적용 회수를 증가시키는 방법
  - KEK를 만들 때 일방향 해시 함수를 여러 번 통과하도록 하면 안전
  - 사용자 입장에서 해시 함수를 1000회 반복하는 것은 용이
  - 공격자 맬로리에게는 작은 차이가 큰 부담
    - 바른 KEK를 찾을 때까지 대량의 패스워드를 시도해야만 함

# 안전한 패스워드를 만들려면

- 자신만이 알 수 있는 정보 사용
  - 중요한 것의 이름 사용 금지
  - 자신에 관한 정보 사용 금지
  - 타인이 보기 쉬운 정보 사용 금지
- 복수의 패스워드를 나누어 쓸 것
  - 하나의 패스워드를 다양한 용도에 사용 금지
  - 정보의 가치에 따라 패스워드 구별 사용해야
  - 패스워드 일부만을 바꾸어 복수 패스워드로 나누어 사용해서는 안됨
- 메모를 유효하게 사용할 것
  - 패스워드를 메모에 써 놓고 컴퓨터 모니터에 붙여 놓아서는 안됨
  - 메모를 유용하게 사용하는 것은 결코 나쁘지 않음
  - 메모를 물리적인 키와 동일하게 취급
  - 패스워드의 일부분만을 메모해 두는 것은 특히 유효
- 패스워드의 한계를 알 것
  - 가정: 영어 알파벳과 숫자 열 개 중의 8문자로 한정
  - 62개 문자
  - 영어 알파벳과 숫자 8문자로 된 문자열의 가능성
    - 62의 8승 = 218,340,105,584,896

## 패스워드의 한계

- 키의 비트 수로 말하면 48비트 정도에 지나지 않는다
- 이 정도의 길이는 전사공격 가능
- 만약 적극적 공격자의 컴퓨터가 1초 간 1억 개 패스워드를 만들 수 있다면 25일에 모든 패스워드 체크 가능

## 패스워드 생성/관리 툴 사용

- 수 많은 웹 사이트 이용 시 다수의 ID와 패스워드 필요
- 패스워드 생성/관리 툴 이용하는 것이 바람직
  - 난수 이용 추측 어려운 패스워드 생성
  - 브라우저와 연계해서 웹 사이트의 패스워드 입력 지원
  - 툴이 사용자의 패스워드를 마음대로 이용하지 않도록 주의
  - 툴과 그 개발처를 신뢰할 수 있는지가 중요

# 퀴즈

## 키의 기초 지식

- 키는 랜덤한 비트 열에 지나지 않으므로 다른사람에게 알려져도 상관 없다 (X)
- 개인 키는 널리 공개해도 괜찮다. (X)
- 디피 헬만 키 교환에서는 공개해도 되는 정보만을 두 사람이 교환해서 공통의 키를 만들어낼 수 있다 (O)
- 중요한 문서의 암호화에 사용하는 패스워드는 자기 어머니의 성과 같은 잊기 어려운 정보를 사용하면 좋다 (X)
