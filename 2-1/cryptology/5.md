# 5주차. 대칭 암호

# 문자 암호에서 비트열 암호로

## 부호화

- 암호화에 컴퓨터 사용이 필수
- 암호화 프로그램도 평문을 비트열로 변경하고 비트열로 된 암호문을 출력
- 부호화(Encoding): 문자열을 비트열로 바꾸는 것

#### ASCII

문자열 midnight을 비트열로 부호화

```
m -> 01101101
i -> 01101001
...
```

## XOR

- 익스클루시브 오아 또는 짧게 엑스오아라고 읽는다
- 배타적 논리합
- XOR은 +와 O를 합친 기호를 써서 표현
- 같은 숫자끼리의 XOR은 반드시 0이 된다

```
0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0
```

#### 비트열 XOR

```
01001100 ... A
10101010 ... B

두 비트열 XOR

11100110 ... A XOR B
```

```
11100110 ... A XOR B
10101010 ... B

두 비트열 XOR

01001100 ... A XOR B XOR B = A
```

#### 암호화/복호화의 순서와 매우 비슷

- 평문 A를 키 B로 암호화하고 암호문 A XOR B를 얻는다
- 암호문 A XOR B를 키 B로 복호화해서 평문 A를 얻는다
- XOR은 그림을 마스크 한다

# 일회용 패드 - 절대 해독 불가능한 암호

## 일회용 패드란

전사공격에서 키공간을 모두 탐색하더라도 해독할 수 없는 암호

## 일회용 패드의 암호화

평문과 랜덤한 비트열과의 XOR만을 취하는 단순한 암호

#### 예시

```
평문: midnight (ASCII로 부호화)
키: 랜덤 비트열

1. 평문과 키를 XOR
```

## 일회용 패드의 복호화

암호문과 키의 XOR을 계산하면 평문이 된다

## 일회용 패드는 해독할 수 없다

- 현실적인 시간 내 해독이 곤란하다는 의미는 아니다
- 키 공간 전체를 순식간에 계산할 수 있는 무한대의 계산력을 갖는 컴퓨터로도 일회용 패드는 해독할 수 없다
- 문자열이 복호화 되었다 하더라도 그것이 바른 평문인지 아닌지 판정할 수 없다

#### 전사공격

- 암호문을 복호화 해보면 도중에 모든 64비트 패턴이 등장한다
- 따라서 어느 것이 바른 평문인지 알 수 없다. 즉 어떤 키를 사용하면 바르게 복호화할 수 있는지 알 수 없다

## 일회용 패드는 왜 사용되지 않은 것일까

- 키 배송
  - 키 길이가 통신문의 길이와 같다
  - 키를 안전하게 보낼 수 있는 방법이 있다면 평문 그 자체를 같은 방법으로 안전하게 보낼 수 없다
- 키 보존
  - 평문과 같은 비트 길이의 키를 안전하게 보존할 수 있다면 평문 그 자체를 안전하게 보존해 둘 수 있다
- 키 재이용
  - 과거에 사용한 랜덤한 비트열은 절대 재이용해서는 안된다
- 키 동기화
  - 통신하는 동안 송수신자 사이에 키가 되는 비트열이 1비트라도 어긋나서는 안 된다
- 키 생성
  - 난수를 대량으로 생성할 필요가 있다
  - 난수는 의사 난수(프로그램을 이용해서 생성하는 난수)가 아니라 실제 난수여야 한다

# DES

- DES는 1977년에 미국의 연방 정보처리 표준 규격으로 채택된 대칭 암호
- 전사공격으로 해독할 수 있는 수준

## 암호화/복호화

- 64비트 평문을 64비트 암호문으로 암호화하는 대칭 암호 알고리즘
- 키의 비트 길이는 56비트
- 64비트 평문을 하나의 단위로 모아서 암호화

#### 블록 암호

- 블록 단위로 처리를 하는 암호 알고리즘
- 긴 비트 길이의 평문을 암호화 위해 평문을 64비트 블록으로 나누고 각각 DES로 암호화 한다

#### DES 구조

- 페이스텔 네트워크
  - 페이스텔 구조
  - 페이스텔 암호
  - DES 외의 다른 블록암호로도 채용
  - 어려 개의 라운드로 구성
  - DES는 16라운드로 구성

#### 페이스텔 네트워크 라운드

1. 입력을 L과 R로 나눈다
2. R을 그대로 R로 보낸다
3. R을 라운드 함수 F로 보낸다
4. 라운드 함수 F는 R과 서브 키 K1을 입력으로 사용하여 랜덤하게 보이는 비트열을 계산한다
5. 얻어진 비트열과 L을 XOR 한다
6. 그 결과를 다음 라운드의 L로 사용한다
7. 마지막 라운드는 L과 R을 교환하지 않는다

#### 페이스텔 네트워크 복호화

같은 서브 키를 사용하여 1라운드를 더 통과시키면 원래대로 돌아간다

#### 페이스텔 네트워크 특징

- 원하는 만큼 라운드 수를 늘릴 수 있다
- 라운드 함수 F에 어떤 함수를 사용해도 복호화가 가능하다
- 암호화와 복호화를 완전히 동일한 구조로 실현할 수 있다

## 차분 해독법과 선형 해독법

- 차분 해독법
  - 블록암호 해독법
  - Biham과 Shamir가 개발
  - 평문의 일부를 변경할 때 암호문이 어떻게 변화하는지 관찰하여 조사하는 암호 해독법
- 선형 해독법
  - 마츠이가 개발
  - 평문과 암호문 비트를 몇 개 정도 XOR 해서 0이 되는 확률을 조사하는 암호 해독법

#### 차분/선형 해독법 전제 조건

- 공격자는 선택 평문 공격(CPA: Chosen Plaintext Attack)을 할 수 있다
- 즉, 암호 해독자가 임의로 만든 평문을 암호화 할 수 있어야 한다

#### AES와 차분/선형 해독법

차분 해독법이나 선형 해독법으로부터 안전하다

# 트리플 DES

## 트리플 DES란

- DES는 전사공격으로 현실적인 시간 내에 해독
- DES를 대신할 블록 암호가 필요
- 이를 위해 개발된 것이 트리플 DES
- DES보다 강력하도록 DES를 3단 겹치게 한 암호 알고리즘

## 트리플 DES 암호화

- 과정
  - 평문
  - 트리플 DES (DES-EDE3)
    - 키 K1로 암호화
    - 키 K2로 복호화
    - 키 K3로 암호화
  - 암호문
- DES로도 사용 가능

#### 트리플 DES 종류

- DES: 모든 키에 같은 비트열을 사용
- DES-EDE2
  - 키1과 키3에 같은 키를 사용하고 키2에 다른 키를 사용
  - EDE는 암호화 -> 복호화 -> 암호화 순서
- DES-EDE3: 키1, 키2, 키3 모두 다른 비트열을 사용

## 트리플 DES 복호화

- 암호화의 역순
- 키3, 키2, 키1의 순으로 복호화 -> 암호화 -> 복호화를 행함

## 트리플 DES의 현황

- 현재도 은행 등에서 사용
- 처리 속도는 빠르지 않고 안전성 면에서도 풀려버린 사례가 있다
- 우리나라에서는 3-DES를 표준으로 정하지 않음
- 우리나라 국가 표준은 SEED 및 ARIA

# AES 선정 과정

## AES란

- DES를 대신한 새로운 표준 대칭 암호 알고리즘
- AES의 후보로서 다수의 대칭 암호 알고리즘을 제안했지만 그 중 Rijndael이라는 대칭 암호 알고리즘이 2000년에 AES로서 선정

## AES 선정 과정

- NIST에서 공모
- 경쟁방식에 의한 표준화
- 조건
  - 제한 없이 무료로 이용
  - ANSI C와 Java에 의한 구현
  - 암호해독에 대한 강도의 평가
  - 암호 알고리즘 설계 규격과 프로그램 공개

## AES 최종 후보 및 선정

- 1차 심사 통과 15개: CAST256, Crypton, DEAL, DFC, E2, Frog, HPC, LOKI97, Magenta, MARS, RC6, Rijndael, SAFER+, Serpent, Twofish
- 2차 심사 통과: 5개
  - MARS - IBM
  - RC6 - RSA
  - Rijndael - Daemen, Rijmen
  - Serpent - Anderson, Biham, Knudsen
  - Twofish - Counterpane

# Rijndael

## Rijndael 이란

- 벨기에 연구자 Daemen과 Rijmen이 설계한 블록 암호 알고리즘
- 블록 길이: 128비트
- 키의 비트 길이
  - 128비트
  - 256비트
  - 32비트

## Rijndael의 암호화와 복호화

- 복수의 라운드로 구성 (10 ~ 14)
- SPN(Substitution-Permutation Network) 구조
- SubBytes (바이트 대체), InvSubBytes (역 바이트 대체, 복호화)
- ShiftRows (행 이동), InvShiftRows (역 행 이동, 복호화)
- MixColumns (열 섞기), InvMixColumns (역 열 섞기, 복호화)
- AddRoundKey (라운드 키와 XOR)

## Rijndael의 해독

- Rijndael의 수식을 수학적인 조작에 의해 풀 수 있다면 Rijndael을 수학적으로 해독할 수 있을 것
- Rijndael에 대한 유효한 공격은 현재로서는 발견되지 않았다

## 어떤 암호를 사용하면 좋은가

- DES: 사용하지 않는다, 과거 SW와 호환성 유지를 위해서만 필요
- 트리플 DES
  - 호환성 문제로 당분간 사용
  - 점차 AES로 대체
- SEED 및 ARIA: 우리나라 표준
- AES(Rijndael)
  - 고속
  - 다양한 플랫폼
  - 현재까지는 안전
  - 사용 권장
  - AES 최종 후보 5개도 사용 가능

---

# 퀴즈

## 문자를 수를 대응시키는 것과 시저 암호

시저 암호에서 사용되는 알파벳은 A부터 Z까지 26문자. 여기에서 A를 0, B를 1... 이렇게 대응시킬 때 시저 암호에서 3문자 앞으로 평행이동이라는 암호화는 어떻게 계산하는 것인가

> 키가 3인 시저암호는 3을 더한 후 26으로 나누고 그 나머지를 구한다
> 나머지를 구하는 것은 23, 24, 25에 대응하는 문자의 경우 처음 알파벳으로 대응 시키기 위함이다

## 일회용 패드와 압축

일회용 패드의 이야기를 들은 앨리스는 일회용 패드에서는 키의 길이와 같다고 하는데, 나는 데이터를 압축하는 프로그램을 가지고 있다. 이것을 사용하면 일회용 패드의 키를 압축해서 짧게 할 수 있지 않을까? 앨리스의 생각은 옳은가?

> 바르지 않다
> 일회용 패드의 키는 어떤 압축 소프트웨어를 써도 압축할 수 없기 때문. 일회용 키는 랜덤하기 때문에 반복 패턴을 갖고 있지 않다.

## 대칭 암호에서 필요한 키의 비트 길기

지금이 당신이 이용할 수 있는 컴퓨터 파워는

- 컴퓨터 1대는 10초 간 10의 20승 개의 키를 시험
- 컴퓨터는 10의 100승 대 존재
- 전체 컴퓨터를 10의 20승 년 움직인다

이정도 컴퓨터 사용 시 키 공간에 속하는 키 전부를 전사 공격으로 조사할 수 없도록 하기 위해 비트 길이는 몇 비트면 되는가?

1. 512비트
2. 1024비트
3. 4096비트
4. 1만비트
5. 100만 비트로도 부족하다

> 512비트
> 1년을 초로 환산 = 365 x 24 x 60 x 60 = 31,622,400 x 키의 총 수 x 컴퓨터 대수 x 컴퓨터 실행 시간
> 3.16224 x 10의 147승
> 2의 512승 = 1.340780 x 10의 154승

## 대칭 암호의 기초 지식

1. 대칭 암호에서는 암호화 키와 복호화 키는 같다 -> O
2. 장래 컴퓨터의 계산력이 충분히 높아지면 일회용 패드의 암호문을 현실적 시간 내에 해독할 수 있게 된다 -> X
3. 키의 길이가 56비트 일 때 전사 공격으로 바른 키가 발견되기까지 평균 시행 횟수는 약 2의 28승 회이다 -> X, 2의 55승
4. AES는 강한 대칭 암호 알고리즘이지만 상용으로 이용하기 위해 NIST에 대해 특허료를 지불해야 한다 -> X
5. AES로 선정된 암호 알고리즘은 Rijndael이다 -> O
