# 11주차. 메시지 인증 코드 & 디지털 서명 (1)

# 메시지 인증 코드

## 올바른 송금 의뢰

- 앨리스: 은행 A의 고객
- 밥: 은행 B의 고객
- A은행에 앨리스로부터 송금 의뢰가 도착
- 내용
  - 내 계좌 앨리스-5374에서 B은행의 계좌 밥-6671로 1억원을 송금바랍니다

#### A 은행이 해야할 일

- 메시지 출처: 인증
- 통신 중 내용 변경 유무: 무결성

#### 메시지 인증

메시지가 올바른 송신자로부터 온 것이다라는 성질

## 메시지 인증 코드

- 메시지 인증 코드 MAC (Message Authentication Code): 무결성을 확인하고 메시지에 대한 인증을 위한 코드
- 입력: 메시지, 공유하는 키
- 출력: 고정 비트 길이의 코드

#### 일방향 해시와 메시지 인증 코드

- 일방향 해시: 키를 사용하지 않는다
- 메시지 인증 코드: 키를 사용

## 메시지 인증 코드 적용 순서

- 앨리스와 수신자 A은행: 사전에 키(K) 공유
- 앨리스: 송금 의뢰 메시지(M) 작성 MAC 값(MACK(M))을 계산
- 앨리스: 수신자 A은행르보퉈 송금 의뢰 메시지와 MAC 값 전송
- 수신자 A은행: 수신한 송금 의뢰 메시지를 기초로해서 MAC 값 계산
- 수신자 A은행: 앨리스로부터 수신한 MAC 값과 자신이 계산한 MAC 값을 비교
- 수신자 A은행
  - 인증성공: 2개의 MAC 값이 동일하면 송금 의뢰가 틀림없이 앨리스로부터 온 것이라고 판단
  - 인증실패: 2개의 MAC 값이 동일하지 않으면 앨리스로부터 온 것이 아니라고 판단

## 메시지 인증 코드의 키 배송 문제

- 대칭 암호 때의 키 배송 문제와 같은 문제가 메시지 인증 코드에도 발생
- 키 배송 문제를 해결
  - 공개 키 암호
  - 디피 헬만 키 교환
  - 키 배포 센터
  - 키를 안전한 방법으로 별도로 보내기

# 메시지 인증 코드 이용 예

## SWIFT

- 국제 은행간 통신협회
- 은행과 은행은 SWIFT를 통해서 거래 메시지 교환
- 메시지 인증 코드를 사용

## IPsec

- 인터넷 기반의 통신 프로토콜인 IP에 보안 기능을 첨가한 것
- 통신 내용 인증과 무결성을 위해 메시지 인증 코드를 이용

## SSL/TLS

- 웹에서 온라인 쇼핑을 할 때 사용되는 통신 프로토콜
- 통신 내용의 인증과 무결성 확인을 위해 메시지 인증 코드를 이용

# 메시지 인증 코드의 실현 방법

## 일방향 해시 함수를 이용한 실현

- SHA-1나 MD5와 같은 일방향 해시 함수를 이용하여 메시지 인증 코드를 실현
- HMAC

## 블록 암호를 이용한 실현

- 트리플 DES나 AES와 같은 블록 암호를 사용해서 메시지 인증 코드를 실현
  - 블록 암호 키를 메시지 인증 코드의 공유키로 사용
  - CBC 모드로 메시지 전체를 암호화
  - 메시지 인증 코드에서는 복호화를 할 필요가 없으므로 최종 블록 이외는 폐기
  - 최종 블록을 MAC 값으로 이용

## 그 밖의 방법으로 실현

- 스트림 암호
- 공개 키 암호

# 인증암호

- 인증 암호(AE 혹은 AEAD)
  - 2000년 이후 연구 진행
  - 대칭 암호와 메시지 인증 코드를 조합하여 기밀성.무결성.인증을 동시에 충족시키는 구조
- Encrypt-then-MAC
  - 평문을 대칭 암호로 암호화한 후 암호문의 MAC 값을 계산
  - 메시지 인증 코드 입력에 암호문을 부여
  - 선택 암호문 공격을 막을 수 있다
- Encrypt-and-MAC
  - 평문을 대칭 암호로 암호화하고, 그와는 별도로 평문의 MAC 값을 얻는 방법
- MAC-then-Encrypt
  - 미리 평문의 MAC 값을 얻고, 평문과 MAC 값 양쪽을 정리하여 대칭 암호로 암호화하는 방법

## GCM과 GMAC

- GCM (Galios/Counter Mode)
  - 인증 모드의 일종
  - AES와 같은 182비트 블록 암호를 CTR 모드로 이용하여 MAC 값을 얻기 위해 덧셈과 곱셈을 반복하는 해시 함수를 사용
  - CTR 모드는 1씩 늘어가는 숫자를 암호화하기 때문에 각 블록을 병렬 처리하여 실행속도를 높일 수가 있음
  - CTR 모드와 MAC 값 생성에 공통 키를 사용하기 때문에 키 관리도 편리
- GMAC(Galios/Counter Mode MAC)
  - GCM을 메시지 인증 코드 전용으로 사용

# HMAC

- HMAC은 일방향 해시 함수를 이용하여 메시지 인증 코드를 구성하는 방법
- HMAC의 일방향 해시 함수는 모듈형으로 골라서 사용
  - HMAC-SHA1: SHA-1
  - HMAC-SHA224: SHA-224
  - HMAC-SHA256: SHA-256
  - HMAC-SHA384: SHA-384
  - HMAC-SHA512: SHA-512
- 새 표준인 SHA-3 KECCAK을 이용해 HMAC 작성 가능

## 순서

- 키에 대한 패딩
- 패딩한 키와 ipad의 XOR
- 메시지 결합
- 해시 값 계산
- 패딩한 키와 opad의 XOR
- 해시 값과 결합
- 해시 값 계산

# 메시지 인증 코드에 대한 공격

## 재전송 공격

보존해 둔 정당한 MAC 값을 반복해서 송신하는 공격

#### 방어

- 순서 번호
  - 송신 메시지에 매회 1씩 증가하는 번호를 붙이기
  - 마지막 통신 시 순서번호 저장
- 타임스탬프
  - 송신 메시지에 현재 시각 넣기
  - 송수신자 사이의 동기화 필요
- 비표
  - 송신자에게 일회용의 랜덤한 값을 전송
  - 메시지와 비표를 합해 MAC 값을 계산
  - 비표 값은 통신 때마다 교체

## 키 추측 공격

- 메시지 인증 코드에 대한 공격
  - 전사공격
  - 생일공격
- MAC 값만 획득한 공격자가 키를 추측하지 못하도록 해야 한다
  - 해시 함수의 일방향성
  - 해시 함수의 충돌내성
  - 키 생성의 의사난수생성기 사용

# 메시지 인증 코드로 해결할 수 없는 문제

## 제 3자에 대한 증명

- 앨리스로부터 메시지를 받은 밥이 이 메시지는 앨리스가 보낸 것이다라는 것을 제 삼자인 검증자 빅터에게 증명 불가
- 이유
  - 일단 키를 빅터에게 알려줘야
  - 앨리스와 밥 모두가 키를 가지고 있으므로 둘 중 누가 작성했는지 말할 수 없다

## 부인 방지

- 밥이 MAC 값이 딸린 메시지를 받았고 이 메시지는 앨리스로부터 온 것이다 라는 걸 확실히 알 수 있음
- 하지만 앨리스가 전송 자체를 부정할 경우 제3자에게 이 사실을 증명 불가
- 부인
  - 앨리스가 송신자체를 부정
- 메시지 인증 코드로는 부인 방지 불가

# 퀴즈

## 메시지 인증 코드의 기초 지식

- 메시지의 인증 코드를 사용하면 메시지의 기밀성이 지켜진다 (X)
- 메시지의 인증 코드를 사용하면 조작을 검출할 수 있다 (O)
- 메시지의 인증 코드를 사요하려면 송신자와 수신자 사이에 공유하는 키가 필요하다 (O)
- 메시지의 인증 코드를 사용하면 부인 방지를 할 수 있닫 (X)

---

# 디지털 서명

## 앨리스의 차용서

- 차용서를 이메일로 보내면 어떨까
  - 메일을 누군가가 변경했을 수 있다
  - 처음부터 앨리스인 것처럼 거짓 행세를 한 누군가가 보낸 것인지도 모른다
  - 나중에 앨리스가 그런 차용서 난 몰라라고 부인할 수도 있다

## 메시지 인증코드에서 디지털 서명으로

#### 메시지 인증 코드의 한계

- 메시지 인증코드를 사용하면 메시지의 변경과 거짓 행세를 검출할 수 있다
- 메시지 인증 코드는 부인 방지에는 도움이 되지 않는다

#### 디지털 서명을 이용한 해결

- 앨리스가 사용하는 키는 앨리스 만이 알고 있는 개인적인 것
- 앨리스는 메시지 송신 시에 그 개인적인 키를 써서 서명을 작성
- 수신자 밥은 앨리스의 키와는 다른 키를 써서 서명을 검증

#### 디지털 서명

- 공개키 암호방식을 이용한 전자서명의 한 종류
- 전자서명은 송신자가 작성한 전자문서 자체를 암호화하는 것이 아니다
- 그 전자서명에 작성자로 기재된 자가 그 전자문서를 작성하였다는 사실과 작성내용이 송.수신과정에서 위조.변조되지 않았다는 사실을 증면한다
- 작성자가 그 전자문서 작성 사실을 나중에 부인할 수 없게 하는 역할을 한다

## 서명 작성과 서명 검증

- 서명을 작성하는 행위
  - 서명용 키와 검증용 키가 나눠져 있어 검증용 키로 서명을 작성할 수는 없다
- 서명을 검증하는 행위
  - 서명옹 키는 서명을 하는 사람만이 가지고 있지만 검증용 키는 서명을 검증하는 사람이라면 누구라도 가질 수 있다

## 공개 키 암호와 디지털 서명

- 공개 키 암호
  - 암호 키와 복호 키가 나눠져 있어 암호키로 복호화를 행할 수는 없다
  - 복호키는 복호화를 행하는 사람만이 가지고 있지만 암호키는 암호화를 행하는 사람이라면 누구나 가질 수 있다
- 디지털 서명
  - 공개 키 암호를 역으로 사용함으로써 실현
  - 메시지를 개인 키로 암호화 = 서명 작성
  - 암호문을 공개 키로 복호화 = 서명 검증

|              | 개인 키                   | 공개 키                     |
| ------------ | ------------------------- | --------------------------- |
| 공개 키 암호 | 수신자 복호화             | 송신자 암호화               |
| 디지털 서명  | 서명자가 서명 작성에 사용 | 검증자들이 서명 검증에 사용 |
| 키 보관      | 개인이 가짐               | 필요한 사람은 아무나 가짐   |

# 디지털 서명 방법

## 메시지에 직접 서명하는 방법

- 앨리스는 자신의 개인 키로 메시지를 암호화
- 앨리스는 메시지와 서명을 밥에게 송신
- 밥은 수신한 서명을 앨리스의 공개 키로 복호화
- 밥은 이제 서명을 복호화해서 얻어진 메시지와 앨리스로부터 직접 수신한 메시지를 비교한다

## 메시지의 해시 값에 서명하는 방법

- 앨리스는 일방향 해시 함수로 메시지의 해시 값을 계산
- 앨리스는 자신의 개인 키로 해시 값을 암호화
- 앨리스는 메시지와 서명을 밥에게 송신
- 밥은 수신한 서명을 앨리스의 공개 키로 복호화
- 밥은 수신한 서명으로부터 얻어진 해시 값과 앨리스로부터 직접 수신한 메시지의 해시 값 비교

# 디지털 서명에 대한 의문

## 암호문이 왜 서명으로서 사용 가능한 것인가

- 개인 키로 암호화한다는 것은 행하고 있는 처리의 내용을 설명한 것이지, 여기에서는 기밀성을 실현하기 위해 암호화하고 있는 것은 아니다
- 인증자
  - 키를 가지고 있는 사람만이 만들 수 있는 정보

## 기밀성을 유지할 수 없는 것은 아닐까

- 맞다. 디지털 서명은 기밀성을 지키기 위한 것은 아니다
- 만약 기밀성이 필요하다면 메시지를 그대로 보내는 것이 아니고 암호화를 별도로 행해서 보내야 된다

## 복사된 서명이 만들어지는 것은 아닐까

- 통상의 파일 복사처럼 서명도 복사본을 간단히 만들 수 있다
- 하지만, 서명 복사를 만들 수 있다고 해서 서명이 무의미해지는 것은 아니다
  - 복사한 데이터가 표현하고 있는 것은 특정의 서명자가 특정의 메시지에 대해서 서명했다고 하는 것뿐이기 때문
  - 복사해도 서명자는 바뀌지 않고 메시지의 내용도 바뀌지 않는다

#### 복사된 서명

- 특정 서명자와 특정 메시지가 결부되어 있다는 사실이 중요
- 아무리 복사를 해도 그 메시지에 누가 서명했는가하는 사실에는 조금도 변화가 없다
- 복사는 할 수 있다. 그러나 그것에 의해 서명이 무의미해지는 것은 아니다

## 서명 변경이 가능한 것은 아닐까

- 확실히 서명한 후에 메시지와 서명의 내용을 수정할 수는 있다. 그러나 수정해버리면 서명의 검증에 실패하기 때문에 검증하는 사람은 수정이 행해졌다는 것을 검출할 수 있다
- 서명 대상의 메시지와 서명 양쪽을 수정해서 서명의 검증에 성공할 수 있도록 앞뒤를 잘 맞출 수 있지는 않을까
  - 아니다. 그것은 사실상 불가능하다

## 서명만 재이용할 수 있는 것은 아닐까

- 확실히 서명 부분만을 잘라내서 다른 메시지에 첨부하는 것은 가능하다
- 그러나 서명의 검증에는 실패한다

## 서명을 삭제하더라도 계약파기를 할 수 없는 것은 아닌가

- 분명히 디지털 서명이 붙은 차용서는 삭제해도 파기할 수 없다
- 디지털 서명이 붙은 차용서를 파기하는 경우에는 영수증에 상당하는 문서를 새로 만들고, 그것에 대해 상대에게 디지털 서명을 부탁해야 한다

## 어떻게 해서 부인 방지가 되는 것인가

- 디지털 서명의 경우 서명을 작성할 수 있는 키(개인 키)는 송신자만 가지고 있다. 그러므로 서명을 작성할 수 있는 것은 송신자뿐이다
- 그렇기에 송신자는 그 서명을 작성한 것은 내가 아니다라고 주장할 수가 없다

## 디지털 서명은 정말로 종이 서명 대용이 되는 것일까

- 한국에서는 1999년 전자서명법이 제정, 시행
- 이 법률들은 전자적으로 실현된 서명을 날인이나 손으로 쓴 서명과 같이 취급하기 위한 법적인 근거
- 그러나 실제는 디지털 서명에 관한 분쟁이 발생하여 디지털 서명의 유효성을 둘러싸고 재판이 일어날 가능성은 충분히 생각할 수 있다

# 디지털 서명 활용 예

## 보안 공지

- 클리어 서명
  - 메시지를 암호화하지 않고 서명만 한 것

## 소프트웨어 다운로드

- 소프트웨어의 작성자가 소프트웨어에 디지털 서명 작성
- 사용자는 다운로드한 후 서명 검증
- 적극적 공격자에 의한 내용 조작을 검출하는 것이 가능

## 공개 키 인증서

- 디지털 서명을 검증
  - 올바른 공개 키가 필요
- 자신이 입수한 공개 키가 바른 공개 키인지 어떤지를 검증하기
- 공개 키 인증서
  - 공개 키를 메시지로 간주하고 그것에 디지털 서명을 한 것
  - 공개 키에 디지털 서명을 붙인 것

## SSL/TLS

- 서버가 올바른 것이라는 것을 인증 위해 서버 인증서 이용
- 서버 공개 키에 디지털 서명한 것
