# 10주차. 하이브리드 암호 시스템 (2) & 일방향 해시함수

# 지난 주 복습

- 하이브리드 암호 시스템
  - 대칭 암호와 공개 키 암호의 장점을 조합한 방법
  - 메시지의 기밀성: 고속의 대칭 암호
  - 대칭 암호 키의 기밀성: 공개 키 암호
- 하이브리드 암호 시스템의 구조
  - 메시지는 대칭 암호로 암호화
  - 대칭 암호의 암호화에서 사용한 세션 키는 의사난수 생성기로 생성
  - 세션 키는 공개 키 암호로 암호화
  - 공개 키 암호의 암호화에서 사용하는 키는 하이브리드 암호 시스템과 무관한 외부에서 만들어 사용

# 강한 하이브리드 암호 시스템이란

- 하이브리드 암호 시스템의 구성 요소
  - 의사난수 생성기
  - 대칭 암호
  - 공개 키 암호
- 각각의 기술 요소의 강도
- 강도의 밸런스도 중요

## 의사난수 생성기

- 세션 키 생성에 사용
- 품질이 나쁘면 만들어지는 세션 키를 공격자가 추측하게 될 위험성
- 세션 키 중 일부 비트라도 추측되지 않도록 주의

## 대칭 암호

- 메시지 암호화에 사용
- 강한 대칭 암호 알고리즘을 사용
- 충분히 길이가 긴 키 사용
- 적절한 블록 암호 모드 사용

## 공개키 암호

- 세션 키 암호화에 사용
- 강한 공개 키 암호 알고리즘 사용
- 충분히 길이가 긴 키 사용

## 키 길이의 밸런스

- 어느 쪽인가 한 쪽의 키 길이가 극단적으로 짧으면, 공격이 그쪽으로 집중될 가능성이 있음
- 대칭 암호와 공개 키 암호의 키 길이는 양쪽이 같은 정도의 강도가 되도록 길이의 균형을 맞춤
- 장기간의 운용을 고려한다면 대칭 암호보다도 공개 키 암호 쪽을 강하게

# 암호 기술의 조합

- 하이브리드 암호 시스템
  - 대칭 암호와 공개 키 암호를 조합해서 양쪽의 장점을 살리는 시스템을 구축
- 블록 암호 모드
  - 고정 키 길이밖에 암호화할 수 없는 블록 암호를 조합해서 보다 긴 평문을 암호화
- 트리플 DES
  - DES를 3개 조합해서 DES보다도 긴 키 길이를 갖는 대칭 암호
- 디지털 서명
  - 일방향 해시 함수와 공개 키 암호를 조합
- 인증서
  - 공개 키와 디지털 서명을 조합
- 메시지 인증 코드
  - 일방향 해시 함수와 키를 조합
  - 대칭 암호로부터 생성
- 의사난수 생성기
  - 대칭 암호
  - 일방향 해시 함수
  - 공개 키 암호

## 기타

- 전자 투표
- 디지털 캐시
- 블라인드 서명
  - 내용을 모르고 서명
- 영 지식 증명
  - 상대에게 정보를 건네지 않고 자신이 그 정보를 가지고 있다는 사실만을 증명해 보이는 방법

# 퀴즈

## 하이브리드 암호 시스템의 기초 지식

- 하이브리드 암호 시스템에서는 대칭 암호를 써서 메시지를 암호화 한다 -> O
- 하이브리드 암호 시스템에서는 공개 키 암호의 개인 키를 써서 메시지를 암호화한다 -> X
- 세션 키는 공개 키 암호로 암호화되기 때문에 세션 키의 비트 길이는 짧아도 상관 없다 -> X (전사 공격에 대한 위험 증가)
- 하이브리드 암호 시스템의 복호화에서는 공개 키 암호의 복호화 -> 대칭 암호의 복호화의 순서로 처리가 진행된다 -> O

---

# 일방향 해시 함수

## 파일의 진위

- 어제 저장한 파일과 오늘의 파일 비교
  - 밤새 맬로리가 파일을 변경했는지 어떤지를 조사하고 싶다
- 무결성
  - 파일이 변경되지 않았다
- 파일의 무결성을 조사하고 싶다
  - 파일을 안전한 장소에 저장후 오늘 불러온 파일과 비교하여 무결성 확인
- 파일의 지문은 없을까
  - 파일 전체를 비교하는 대신 작은 지문 비교하는 것만으로도 무결성 확인 가능하면 매우 편리할 것

#### 해시 값 비교 방법

- 어제 만든 파일 해시 함수를 통해 해시 저장
- 오늘 불러온 파일 해시 함수로 나온 해시와 어제 저장한 해시 비교

## 일방향 해시 함수란

- 파일의 지문 채취 기술
- 일방향 해시 함수가 만들어내는 해시 값은 메시지의 지문에 해당
- 예
  - 입력: 임의의 숫자
  - 처리: 입력되는 숫자를 23으로 나누는 메커니즘
  - 출력: 그 몫을 소수로 표현했을 때 소숫점 이하 7자리부터 10자리까지 4자리 숫자
- 입력과 출력이 각각 1개씩 있다
- 입력은 메시지
- 출력은 해시 값
- 일방향 해시 함수는 메시지를 기초로 해서 해시 값을 계산

#### 일정한 크기의 출력

- 해시 값의 길이는 메시지의 길이와는 관계가 없다
- 메시지가 1비트라도, 1메가바이트라도, 100기가바이트라도 일방향 해시 함수는 고정된 길이의 해시 값을 출력
- SHA-1의 출력은 항상 160비트

## 일방향 해시 함수의 성질

- 임의의 길이 메시지로부터 고정 길이의 해시 값을 계산
  - 어떠한 크기 메시지라도 크기에 관계 없이 입력으로 사용할 수 있어야
  - 어떤 길이의 메시지를 입력으로 주더라도 일방향 해시 함수는 짧은 해시 값을 생성
- 해시 값을 고속으로 계산 가능
  - 해시 값 계산은 고속이어야
  - 메시지가 길어지면 해시 값을 구하는 시간이 길어지는 것은 어쩔 수 없다
  - 현실적인 시간 내에 계산할 수 없다면 소용 없다
- 메시지가 다르면 당연히 해시 값도 다르다
  - 메시지가 1비트라도 변화하면 해시 값은 매우 높은 확률로 다른 값이 돼야 한다
- 일방향성을 갖는다
  - 해시 값으로부터 메시지를 역산할 수 없다
  - 메시지로부터 해시 값을 계산하는 것은 간단히 할 수 있다
  - 해시 값으로부터 메시지를 계산하는 것은 불가능해야

#### 해시 함수의 충돌

- 충돌: 2개의 다른 메시지가 같은 해시 값을 갖는 것
- 충돌 내성: 충돌을 발견하는 것이 어려운 성질
  - 약한
    - 어느 메시지의 해시 값이 주어졌을 때, 그 해시 값과 같은 해시 값을 갖는 다른 메시지를 발견해 내는 것이 매우 곤란한 성질
  - 강한
    - 해시 값을 일치할 것 같은 다른 2개의 메시지를 발견해 내는 것이 매우 곤란한 성질

## 해시 함수 관련 용어

- 일방향 해시 함수
  - 메시지 다이제스트 함수
  - 메시지 요약 함수
  - 암호적 해시 함수
- 일방향 해시 함수의 입력이 되는 메시지
  - 프리.이미지
- 해시 값
  - 메시지 다이제스트
  - 핑거프린트
- 무결성
  - 완전성
  - 보전성

# 일방향 해시 함수의 응용

## 소프트웨어의 변경 검출

- 자신이 입수한 소프트웨어가 변경 되었는지를 확인하기 위해 일방향 해시 함수를 사용

## 패스워드를 기초로 한 암호화

- PBE에서는 패스워드와 솔트를 섞은 결과의 해시 값을 구해 그것을 암호화 키로 사용
- 패스워드 사전 공격 방어

## 메시지 인증 코드

- 송신자와 수신자만이 공유하고 있는 키와 메시지를 혼합해서 그 해시 값을 계산한 값
- 통신 중의 오류나 수정 그리고 가장(위장)을 검출 가능
- SSL/TLS에서 이용

## 디지털 서명

- 현실 사회의 서명이나 날인에 해당하는 온라인 상의 서명
- 처리 시간 단축을 위해 일방향 해시 함수를 사용해서 메시지의 해시 값을 일단 구하고, 그 해시 값에 대해 디지털 서명 수행

## 의사난수 생성기

- 일방향 해시 함수를 이용한 의사난수 생성
- 암호 기술에 필요한 난수
  - 과거의 난수열로부터 미래의 난수열을 예측하는 것은 사실상 불가능이라는 성질이 필요
  - 그 예측 불가능성을 보증하기 위해 일방향 해시 함수의 일방향성을 이용

## 일회용 패스워드

- 원타임 패스워드
  - 정당한 클라이언트인지 아닌지를 서버가 인증할 때에 사용
  - 일방향 해시 함수를 써서 통신 경로 상에 흐르는 패스워드를 1회만 사용하도록 고안
  - 패스워드가 도청되어도 악용될 위험성이 없다

# 일방향 해시 함수의 예

## MD4와 MD5

#### MD4

- 라이베스트가 1990년에 만든 일방향 해시 함수
- 128비트의 해시 값
- Dobbertin에 의해 충돌 발견 방법 고안
- 현재는 안전하지 않다

#### MD5

- 라이베스트가 1991년에 만든 일방향 해시 함수
- 128비트의 해시 값
- 암호해독에 취약함을 보여주는 여러 가지 암호해독 방법들이 개발
- MD5가 완전히 뚫린 것은 아님
  - MD5 내부 구조 일부에 대한 몇 가지 공격 방법 발견
- 사용 권장 안함

## SHA-1, SHA-256, SHA-384, SHA-512

#### SHA-1

- NIST에서 제작
- 160비트의 해시 값
- SHA
  - 1993년에 미국의 연방정보처리표준
- SHA-1
  - 1995년에 발표된 개정판
  - 2005년에 암호학적으로 공격에 취약한 것이 밝혀짐
  - 2010년 이후로는 호환성 유지 목적으로만 사용

#### SHA-2

- SHA-256
  - 256 비트의 해시 값
  - 메시지의 길이 상한 2의 64비트 미만
- SHA-384
  - 256 비트의 해시 값
  - 메시지의 길이 상한 2의 128비트 미만
- SHA-512
  - 512 비트의 해시 값
  - 메시지의 길이 상한 2의 128비트 미만

## RIPEMD-160

- 1996년에 Hans Dooberitn, Antoon Bosselaers, Bart Preneel이 제작
- 160비트의 해시 값
- 유로피안 유니온 RIPE 프로젝트로 만들어진 RIPEMD 함수의 개정판
- 비트코인에서 사용
- 별도 버전
  - RIPEMD-128, RIPEMD-256, RIPEMD-320

## SHA-3

- SHA-1의 강한 충돌 내성 침해
- NIST는 SHA-1을 대체하는 차세대 일방향 해시 함수로 2007년에 SHA-3 선정 시작
- AES와 같은 경쟁 방식으로 표준화
- 2012년 선정 완료
  - KECCAK을 표준으로 선정
  - 이것이 SHA-3

# 일방향 해시 함수 SHA-512

## 구조

- 입력: 최대 2의 128비트 이하 메시지
- 출력: 512비트 메시지 다이제스트
- 입력 데이터는 길이 1024비트 블록으로 처리

## 처리 단계

- 패딩 비트 붙이기
  - 메시지 뒤에 여분의 데이터를 부가하여 메시지의 길이가 896 (mod 1024)가 되도록 만듦
  - 메시지가 1024비트의 배수여도 패딩 추가
  - 패딩의 첫 번째 비트는 1
  - 나머지 비트는 모두 0
- 길이 붙이기
  - 128비트 블록 K를 메시지에 추가
  - 1024 비트 블록들을 M1, M2, ..., MN으로 표현
  - 총 길이 = N \* 1024 비트
- MD 버퍼 초기화
- 1024-비트(128-워드) 블록 메시지 처리
  - 각 라운드가 80 라운드로 구성
  - 각 라운드에서 512 비트 버퍼 abcdefgh를 입력으로 사용
- 출력
  - N개의 1024-비트 블록을 모두 처리하면 N번째 단계에서 512-비트 메시지 다이제스트가 출력

## 안전성

- 2017년까지 약점 발견된 것 없음
- 확률적 안전성
  - 약 충돌성: 동일한 메시지 다이제스트를 갖는 두 개의 서로 다른 메시지를 찾는 난이도 연산 수행 수는 2의 256승
  - 강 충돌성: 주어진 다이제스트와 동일한 다이제스트를 갖는 메시지를 찾는 난이도 연산 수행 수는 2의 512승

# SHA-3 선정 과정

## SHA-3란 무엇인가

- 이론적 공격방법이 알려져 버린 SHA-1을 대신하는 새로운 표준의 일방향 해시 알고리즘
- 2012년에 KECCAK이라는 알고리즘을 SHA-3으로 선정

## SHA-3 선정 과정

- 미국 표준화 기관 NIST에서 공모
- 실질적으로는 세계적인 표준
- 경쟁방식에 의한 표준화 방식으로 선정

## SHA-3 최종 후보와 SHA-3 결정

- NIST에서 2007년에 SHA-3 공모
- 2008년까지 응모한 알고리즘 수는 64개
- 2010년에 SHA-3 최종후보로서 5개의 알고리즘이 선정
- SHA-2와 SHA-3 공존해서 사용
- KECCAK이 SHA-3로 선정된 이유
  - SHA-2와 전혀 다른 구조
  - 구성이 투명하여 구조를 해석하기 쉬움
  - 다양한 디바이스에서 구동되고 조합 형태로도 양호
  - 하드웨어 상에 내장 시 높은 고성능
  - 다른 최종 목록과 비교하여 보안성이 높음

# KECCAK

## KECCAK이란 무엇인가

- SHA-3으로 선정된 일방향 해시 함수 알고리즘
- 해시 값으로서 임의 길이의 비트열 생성
- SHA-2 비트 길이에 맞춰져 있음
- SHA3-224, SHA3-256, SHA3-384, SHA3-512 4종류가 SHA-3으로 규정
- 입력 데이터 크기에 제한 없음
- SHAKE128과 SHAKE256이라는 임의 길이의 출력을 가진 함수 (extendable-outpu function; XOF)를 규정
  - SHAKE = Secure Hash Algorithm + KECCAK

## 스펀지 구조

- SHA-1과 SHA-2와는 전혀 다른 스펀지 구조가 사용됨
- 입력되는 메시지에 패딩을 시행한 후 흡수 단계와 추출 단계라는 두 개의 상태를 통해서 해시 값을 출력

#### 흡수 단계

- 패딩된 입력 메시지를 r 비트 단위의 입력 블록으로 분할
- 우선 내부 상태의 r 비트와 입력 블록 1의 XOR을 구하고 그것을 함수 f에 입력
- 다음에 함수 f의 출력 r 비트와 입력블록 2을 XOR하고, 그것을 다시 한 번 함수 f에 입력
- 이 과정을 입력 블록이 다 할 때까지 계속
- 입력 블록을 다 처리하면 흡수 단계를 종료하고 추출 단계를 진행

#### 추출 단계

- 우선 함수 f의 출력 중 r 비트를 출력 블록 1로 기술하고 출력전체(r + c 비트)는 함수 f로 다시 입력
- 다음에 함수 f 출력 중 r 비트를 출력 블록 2로 기술하고, 출력전체(r + c 비트)는 함수 f로 다시 입력
- 이것을 필요한 비트 수의 출력을 얻을 때까지 계속 반복

## 듀플렉스 구조

- 입력과 출력이 같은 속도로 진행
- 해시 값을 구하는 용도만이 아니라 의사난수 생성기, 스트림 암호, 인증이 포함된 암호, 메시지 인증 코드 등 암호학자의 도구상자에 들어있는 대부분의 기능을 활용할 수 있음

## KECCAK의 내부 상태

- 3차원 비트 배열
- 1비트를 나타내는 작은 입방체가 b개, 즉, 5 x 5 x z 방향수 만큼 큰 육면체
- 내부 상태의 일부
  - 상태(state)
    - x, y, z의 모든 방향을 고려한 3차원 내부상태 전체
  - 플레인: x, z
  - 슬라이스: x, y
  - 시트: y, z
  - 로우: x
  - 칼럼: y
  - 레인: z
  - 비트: 하나

## 함수 KECCAK-f[b]

- 내부 상태를 혼합하는 함수
- b를 폭이라고 함
  - b = 25, 50, 100, 200, 400, 800, 1600 7종류
  - SHA-3에서는 b = 1600 사용
  - SHA-3의 내부상태 b = 5 x 5 x 64 = 1600 비트
- 아래에 설명하게 될 세타, 로우, 파이, 카이, 아이오타라는 5개 단계를 1라운드라고 할 때 총 12 + 2아이오타 라운드를 반복하는 함수
- SHA-3으로 사용되는 KECCAK-f[1600]의 경우 라운드 수는 24

## 세타 단계

위치를 이동시킨 칼럼 2개의 5 비트를 XOR하여 그 결과를 목적 비트와 XOR 처리 후 목적 비트를 대체

## 로우 단계

z방향(레인 방향) 비트 이동

## 파이 단계

비트 이동을 레인 전체에 대해 수행

## 카이 단계

논리회로 NOT과 AND 연산을 활용하여 수행

## 아이오타 단계

- 라운드 정수라고 불리는 정수와 단계 전체의 비트를 XOR 처리
- 내부 상태의 비대칭성을 위해 수행

## KECCAK에 대한 공격

- MD변환
  - MD4, MD5, RIPEMD, RIPEMD-160, SHA-1, SHA-2 등, 지금까지 거의 일방향 해시 함수 알고리즘에서 이용
- SHA-1에 대한 논리적인 공격방법이 발견
- SHA-2는 SHA-1과 같은 MD구조를 사용했기 때문에 근본적으로 문제를 해결할 필요가 있음
- KECCAK은
  - MD구조와 다른 스펀지 구조로 만들어져 있기 때문에 SHA-1을 공격한믄 데 사용된 방법이 KECCAK에는 통용되지 않음
  - 현재까지 공격 방법이 알려진 것이 없음

## 약한 KECCAK에 대한 공격 테스트

- KECCAK은 반복되는 구조로 되어 있고 여러 라운드로 구성됨
- 약한 KECCAK을 구성하는 것이 가능
- KECCAK Crunch Crypto Collision and Pre-image Contest
  - 구조를 명확히 해 해석이 쉽도록 간략형 KECCA을 만들고 이를 공격해보는 콘테스트
  - SHA-3의 안전도 측정 방법

# 일방향 해시 함수에 대한 공격

## 전사 공격

- 일방향 해시 함수의 약한 충돌내성을 깨고자 하는 공격
- 맬로리는 앨리스의 컴퓨터에서 계약서 파일을 발견하고 그 안의 앨리스의 지불금액 100만원을 1억원으로 바꿈
- 문서의 의미를 바꾸지 않고 얼마만큼 파일을 수정할 수 있을까, 동일한 내용을 다른 형태로 표현
- 그 중 앨리스가 만든 오리지널 계약서와 같은 해시 값을 생성하는 것을 발견할 때 까지 작성해봄

## 생일 공격

- 강한 충돌 내성을 깨고자 하는 공격
- 맬로리는 해시 값이 같은 값을 갖는 100만원 계약서와 1억원 계약서를 미리 만들어 둔다
- 맬로리는 시치미를 떼고 100만원 계약서를 앨리스에게 건네주고 해시 값을 계산 시킨다
- 맬로리는 스토리1과 마찬가지로 100만원 계약서와 1억원 계약서를 살짝 바꾼다
- N명 중 적어도 2명의 생일이 일치할 확률이 2분의 1 이상이 되도록 하기 위해서는 N은 최저 몇 명이면 될까
  - 23명
  - 어느 특정일을 정하고 2명이 그 날 태어날 가능성은 높지 않다
  - 그러나 1년의 어느 날이라도 상관 없으므로 2명이 같은 날 태어날 가능성은 의외로 높다
- 맬로리는 100만원 계약서 1억원 계약서 N개 작성
- 맬로리는 각각의 계약서끼리 비교해서 일치하는 것이 있는지 찾는다
- 발견되면 두 계약서를 가지고 속이러 간다

#### N의 크기

- 문제가 되는 것은 N의 크기
- N이 작으면 공격 성공 가능 높음
- N이 크면 시간도 메모리도 많이 필요해서 생일 공격은 어려워짐
- N은 해시 값의 비트 길이에 의존

## 스토리 비교

- 스토리1
  - 앨리스가 백 만원 계약서를 만들어서 해시 값은 고정
  - 맬로리는 그 해시 값과 같은 메시지를 발견해 내는 약한 충돌 내성 공격
- 스토리2
  - 맬로리가 2 개의 계약서를 만드는 것이므로 해시 값은 뭐라도 상관 없음
  - 100만원 계약서와 1억원 계약서의 해시 값이 같기만 하면 됨

# 어떤 일방향 해시 함수를 사용하면 좋을까

- MD5는 안전하지 않으므로 사용해서는 안된다
- SHA-2는 SHA-1에 대한 공격방법에 대한 대처를 하여 고안해서 안전
- SHA-3는 안전
- 자작 알고리즘은 안됨

# 일방향 해시 함수로 해결할 수 없는 문제

- 일방향 해시 함수는 조작 또는 변경 검출은 가능하나 거짓행세 검출을 못한다
- 인증
  - 이 파일이 정말로 앨리스가 작성한 것인지를 확인하는 것
  - 인증을 수행하기 위한 기술
    - 메시지 인증 코드
    - 디지털 서명

# 정리

- 일방향 해시 함수
  - 임의의 길이의 메시지로부터 공정 길이의 해시 값을 계산
  - 해시 값을 비교하는 것만으로 2개의 메시지가 같은지 판단 가능
  - 메시지 변경 같은 조작 검출에 유효한 기술
  - 조작은 검출 가능하나 거짓행세 검출은 불가능(메시지 인증 코드나 디지털 서명 필요)

# 퀴즈

## 일방향 해시 함수의 기초 지식

- SHA3-512는 임의의 길이 데이터를 512비트로 변환하는 대칭 암호 알고리즘의 일종이다 -> X, 일방향 해시 함수
- 어떤 메시지의 해시 값과 같은 해시 값을 갖는 다른 메시지를 발견해 해는 것은 지극히 곤란하다 -> 애매하다
- 같은 해시 값을 갖는 다른 2개의 메시지를 발견해 내는 것은 지극히 곤란하다 -> 애매하다
- SHA3-512의 해시 값은 64바이트다 -> O, 512비트
- 메시지를 1비트만 변경하면 해시 값도 1비트만 변화한다 -> X
