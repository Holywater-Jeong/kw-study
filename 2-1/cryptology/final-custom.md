# 기말고사 개인 정리

## 대칭 암호

한 개의 키로 암호화하고 같은 키로 복호화한다

### XOR

- 엑스오아, 배타적 논리합
- 같은 것이 두 개 만나면 XOR는 0이 된다, 다른 것 끼리 만나야 1이 된다

#### 비트열 XOR

- 같은 비트열로 한 비트열에 XOR을 2번 반복하면 원래대로 돌아간다
- 마스크가 랜덤한 비트 패턴이라면 XOR을 수행했을 때 원래 그림을 감출 수 있다
  - 이 예측 불가능한 비트열을 만들 수 있다면 암호 기술에 유용하게 사용할 수 있다
  - 이 것을 난수라고 부른다

### 일회용 패드

- 절대로 해독 불가능하다
  - 전사공격에서 키공간 모두 탐색을 해도 불가능
- 평문과 랜덤한 비트열과의 XOR만을 취하는 단순 암호
- 암호화 복호화 모두 랜덤한 비트열로 XOR 한다 (암호화 시에는 평문을 복호화 시에는 암호문을)
- 왜 해독할 수 없나
  - 설령 복호화가 되었다고 하더라도 바른 평문인지 판정할 수가 없는 것

#### 사용되지 않는 이유

##### 키 배송 문제

- 암호화한 키를 잘 전달해야하는데 그 키의 길이가 통신문의 길이와 같다
- 키를 안전하게 보낼 수 있다면 평문 그 자체를 같은 방법으로 안전하게 보낼 수 있을 것

##### 키 보존

- 평문과 같은 비트 길이의 키가 필요
- 게다가 그 키는 도청자에게 지키지 않게 보존되어야
- 하지만 평문과 같은 길이의 키를 안전하게 보존할 수 있다면 그 평문을 보존해둘 수 있을 것

##### 키 재사용

- 과거에 사용한 랜덤한 비트열을 절대로 재사용하면 안된다

##### 키 동기화

- 수신자의 동기화도 문제가 된다
- 평문이 길면 일회용 패드의 길이도 길어짐
- 통신 간 1 비트라도 어긋나면 복호화 불가능

##### 키 생성

- 난수를 대량으로 생성해야 한다
  - 의사난수가 아닌 실제 난수여야함
- 키의 생성과 배송에 막대한 비용과 노력이 필요해서 비용과 상관 없이 기밀성이 최우선인 경우에만 사용
- 임무를 맡은 에이전트가 직접 키를 운반
- 일회용 패드의 아이디어는 스트림 암호에 활용 중

### DES

- 1977년 미국 연방 정보처리 표준 규격으로 채택된 대칭 암호

#### 암/복호화

- 64비트 평문을 64비트 암호문으로 암호화하는 대칭암호 알고리즘
- 키의 비트 길이는 56비트, 7비트 마다 오류 검출 위한 정보 1비트 씩 들어가기에
- 64비트 평문을 하나의 단위로 모아 암호화, 블록 단위로 처리하는 알고리즘을 블록 암호라고 하므로 블록 암호다
- DES로 한 번에 암호화할 수 있는 것은 64비트, 긴 비트의 길이의 평문 암호화 위해서는 암호화 반복 해야함
  - 반복하는 방법을 모드라 한다

##### DES 구조

- 페이스텔 네트워크, 페이스텔 구조, 페이스텔 암호라 불린다
  - 그물을 짜는 것 같이 교환되는 형태로 구성되어 있기 때문에 붙여졌다
- 라운드라는 암호화의 한 단계를 여러 번 반복 수행하도록 되어있다
  - DES는 라운드 16회 반복하는 페이스텔 네트워크다

#### 페이스텔 네트워크

1. 입력을 L과 R로 나눈다
2. R을 그대로 R로 보낸다
3. R을 라운드 함수 F로 보낸다
4. 라운드 함수 F는 R과 서브 키 K1을 입력으로 사용하여 랜덤하게 보이는 비트열을 계산한다
5. 얻어진 비트열과 L을 XOR 한다
6. 그 결과를 다음 라운드의 L로 사용한다
7. 마지막 라운드는 L과 R을 교환하지 않는다

##### 페이스텔 네트워크 복호화

같은 서브 키를 사용하여 1라운드를 더 통과시키면 원래대로 돌아간다

##### 페이스텔 네트워크 특징

- 원하는 만큼 라운드 수를 늘릴 수 있다
- 라운드 함수 F에 어떤 함수를 사용해도 복호화가 가능하다
- 암호화와 복호화를 완전히 동일한 구조로 실현할 수 있다

#### 차분해독법과 선형해독법

##### 차분해독법

- 평문의 일부를 변경하면 암호문이 어떻게 변화하는지 조사

##### 선형 해독법

- 평문과 암호문 비트를 몇 개 정도 XOR 해서 0이 되는 확률 조사

> 두 방법 모두 암호 해독자가 임의로 만든 평문을 암호화할 수 있다는 가정을 해둔다. 이것을 선택 평문 공격(CPA)라고 한다

### 트리플 DES

- 최근 DES는 전사공격으로 현실적 시간 내 해독 가능, 이를 위해 개발된 것임
- DES를 3단 겹치게 한 알고리즘
- 3중 DES, TDEA, 3DES 등으로 불린다

#### 암호화

- 평문이 3번 DES 처리 과정 거쳐서 암호문이 됨
- DES 키는 실질적으로 56비트 이므로 3DES 키는 168비트가 됨
- `암 -> 복 -> 암`
  - 트리플 DES를 단독 DES로도 사용할 수 있게 IBM 사가 고안
    - 트리플 DES에서 모든 키를 동일하게 하면 트리플 DES는 보통 DES와 같아진다
    - 최초 두 번 암호화 -> 복호화로 원래 평문으로 돌아가기 때문
  - 모든 키에 같은 비트열 사용 -> 단독 DES
  - 키1과 키3에 같은 키를 사용하고 키2에 다른 키를 사용하는 트리플 DES -> DES-EDE2
  - 키1,2,3 모두 다른 비트열 사용 시 DES-EDE3

#### 복호화

- 암호화의 역
- 키3, 키2, 키1 순으로 `복 -> 암 -> 복`

#### 현황

- 처리 속도가 느림
- DES암호화 자료와 호환성 중시 경우 제외하고 새로운 용도로는 사용 드물다
- 우리나라는 SEED, ARIA 사용 중

### AES 선정 과정

- DES 대신하는 표준 대칭 알고리즘
- 그 중 라인달이라는 대칭 암호 알고리즘이 2000년 AES로 선정

#### 선정 과정

##### 응모 조건

- 무조건 무료 사용
- ANSI C, JAVA로 구현
- 암호 해독에 대한 강도 평가
- 알고리즘 설계 규격, 프로그램 공개하고 강도를 유지하지 않으면 안됨
  - 감추는 것에 의한 보안 X

> 경쟁 방식에 의한 표준화

#### 최종 후보 및 선정

- 최초 평가대상 15개
- 고려되는 것은 약점의 유무 만이 아니라 속도가 빠르고 단순하고 구현이 쉬워야하는 것도 고려됨
- 암호화 자체 속도뿐만 아니라 키의 설정 속도도 중요
- 스마트카드, 8비트 CPU 등 계산 능력 낮은 플랫폼에서부터 모두 효율적 이용 가능해야

### 라인달

#### 암/복호화

- 복수 라운드
- 1라운드는 Sub-Bytes, ShiftRows, MixColumns, AddRoundKey라는 4개 처리를 계속해서 함
  - SPN 구조
  - SubBytes (바이트 대체), InvSubBytes (역 바이트 대체, 복호화)
  - ShiftRows (행 이동), InvShiftRows (역 행 이동, 복호화)
  - MixColumns (열 섞기), InvMixColumns (역 열 섞기, 복호화)
  - AddRoundKey (라운드 키와 XOR)

#### 해독

- 라인달 알고리즘 배후에는 수학적 구조가 있어 평문에서 암호문을 만들어내는 계산을 수식으로 표현하는 것이 가능
- 이 것은 공격당할 가능성이 있음

#### 어떤 암호를 사용할까

- 점차 AES로 사용될 것
- 우리나라는 SEED, ARIA
- 자체 개발 알고리즘은 사용 안해야

---

## 공개 키 암호

공개 키로 암호화하고 개인 키로 복호화한다

### 키 배송 문제

- 대칭 키를 사용 시 상대에게 키를 공유하지 않으면 안 됨
- 도청당할 우려가 있을 때는 어려움을 겪음

#### 해결 방안

##### 키 사전 공유

- 안전한 방법으로 미리 공유한다면 안전하지만 사람 수가 많아지면 어렵다

##### 키 배포 센터

- 통신 필요 시 센터에 의뢰해 배포 센터에서만 키를 사전 공유
  - 위 과정이 꽤나 복잡해 이런 통신이 많아지면 컴퓨터 부하
- 키 배포 센터 컴퓨터에는 모든 키가 보존
  - 공격자의 공격을 받을 시 리스크가 크다
- 각 이용자가 배포 센터를 신뢰해야 한다는 문제도 있다

##### 디피-헬만 키 교환

- 송수신자가 정보를 서로 주고받는다는 의미
  - 특정 정보를 먼저 교환, 이 정보는 도청당해도 상관 없다
- 교환한 특정 정보를 가지고 동일한 키를 각각 만들어낼 수 있음

##### 공개 키 암호

- 암호화 키는 공개하여 누구나 암호화 가능
- 복호화 키는 개인만 가지고 있다

### 공개 키 암호

- 암호화 키는 송신자가 사용, 복호화 키는 수신자가 사용
  - 송신자: 암호화 키만 필요
  - 수신자: 복호화 키만 필요
  - 도청자에게 복호화 키만 안 알려지면 됨
- 이 둘을 키 쌍이라 부른다
- 표준 격인 RSA를 1978년 발표 (라이베스트, 샤미르, 애들먼)

#### 흐름

- 밥은 공개/개인 키로 한 상의 키를 만들어 개인 키는 보관
- 밥은 자신의 공개 키 앨리스에게 보냄
- 앨리스는 밥의 공개 키로 메시지를 암호화
- 해당 암호문을 밥에게 보냄
- 밥은 자신의 개인 키로 복호화

#### 용어

- 비대칭이라는 용어: 대칭 암호와 반대이기 때문, 키를 대칭하여 사용 안 함
- 개인 키 = 비밀 키

#### 해결 불가능 문제

- 입수한 공개 키가 바른 공개 키인지 알 수 없음
  - 공개 키 인증에 관한 문제
  - 중간자 공격
- 대칭 암호에 비해 몇 백배 느리다는 문제

#### 시계 연산

mod 연산 (n으로 나눈 나머지를 구하는 연산)

### RSA

- 공개 키 암호와 디지털 서명에 사용 가능

#### 암호화

`암호문 = 평문의 E승 mod N`

- E와 N의 쌍이 공개 키에 해당

#### 복호화

`평문 = 암호문의 D승 mod N`

- D와 N의 쌍이 개인 키에 해당

#### 키 쌍의 생성

- N을 구한다
  - 큰 소수 p와 q 구함
- L을 구한다 (키 쌍 생성 시에만 등장)
  - p-1과 q-1의 최소 공배수
- E 구함
  - 1보다 크고 L보다 작은 수
  - E와 L과 최대 공약수가 1이 아니면 안 됨
- D 구함
  - 1보다 크고 L보다 작은 수
  - `E x D mod L = 1`인 수

### RSA에 대한 공격

- 암호 해독자가 아는 것
  - 암호문
  - E와 N
- 암호 해독자가 모르는 것
  - 평문
  - D
  - 기타: p, q, L

#### 암호문으로부터 평문 구하기

- `mod N`이 붙어 이산대수를 구하는 빠른 방법이 없어 힘들다

#### 전사 공격

- 수 D를 알면 복호화 가능
- D의 후보가 되는 수 순서대로 복호화하는 전사 공격 생각 가능
  - 그러나 D 비트 수가 크다면 어렵다
  - 1024비트 이상의 전사 공격을 하려면 어려움

#### E와 N으로부터 D 구하기

- 중요한 포인트 p와 q를 모르면 어렵다, p와 q를 구한다는 것은 자연수 N을 소인수 분해한다는 것과 같다
- 큰 수의 소인수 분해를 고속으로 할 수 있으면 RSA 해독 가능

#### 중간자 공격

- RSA를 해독하는 것은 아님 기밀성에 대한 매우 유효한 공격 방법
- 적극적 공격자가 송수신자 사이에서 송신자에게는 수신자처럼, 수신자에게는 송신자처럼 행세하는 것

#### 선택 암호문 공격

- 복호 오라클
  - 임의의 데이터를 송신하면 그것을 암호문으로 간주하고 회신해주는 서비스
- 선택 암호문 공격
  - 복호 오라클 공격을 공격자가 이용할 수 있다고 가정한 공격
  - 공격 대상인 암호문은 제외

##### 복호 오라클 서비스의 의미

- 넌센서츠럼 보이지만 실제 네트워크에서 오류메시지 반환을 악용하는 공격
- 위조 암호문을 여러 차례 전송하여 반환된 오류 메시지나 타이밍 정보를 활용해 평문을 추측
- RSA의 경우 선택 암호문 공격으로 약간의 정보 취득 가능

##### RSA-OAEP(Optimal Asymmetric Encryption Padding)

- RSA를 개량해서 선택 암호문 공격으로부터 안전하게 만든 것
- 암호문에 인증 과정을 추가한 방법
- 평문 해시 갑소가 정해진 개수의 0 등으로 만들어진 인증정보를 평문 앞에 추가한 뒤 그 후에 RSA로 암호화한다
- 복호화 시 RSA로 복호화한 후 선두에 올바른 인증 정보가 나타나지 않으면 오류 판정

---

## 하이브리드 암호 시스템

대칭 암호로 속도를 높이고 공개 키 암호로 세션 키를 보호한다

### 하이브리드 암호 시스템

- 메시지를 고속의 대칭 암호로 암호화
  - 메시지의 기밀성 지킴
  - 대칭 암호 암호화에서 사용한 세션 키는 의사난수 생성기로 생성
- 메시지를 암호화 할 때 사용한 대칭 암호 키를 공개 키 암호로 암호화
  - 메시지 길이에 비해 대칭 암호 키 길이는 짧아 짧은 데이터 암호화 시 공개 키 암호화의 느린 속도 문제되지 않음
  - 공개 키 암호의 암호화에서 사용하는 키는 하이브리으 암호 시스템 외부로부터 부여
- 사용 기술
  - 의사난수 생성기

#### 암호화

##### 표현 방법

평문.키.암호문

- P: 평문
- Kpub: 수신자의 공개 키
- C2: 공개 키 암호로 암호화된 세션 키
- C1: 대칭 암호로 암호화된 메시지
- C=(C1, C2): 암호문

##### 메시지 암호화

- `C1 = E(K, P)`
- 대칭 암호 이용해서 암호화
- 대칭 암호를 이용하면 고속으로 암호화

##### 세션 키 암호화

- `C2 = E(Kpub, K)`
- 수신자의 공개 키로 암호화됨
- 세션 키는 짧음
- 공개 키 암호가 아무리 느려도 세션 키 암호화에 그다지 오랜 시간이 걸리지 않는다
- 세션 키는 대칭 암호에 있어서는 키이지만, 공개 키 암호의 입장에서 보면 하나의 평문

##### 결합

- 대칭 키(K)로 암호화된 암호문(`C1 = E(K, P)`)
- 수신자의 공개 키(Kpub)로 암호화된 세션 키(`C2 = E(Kpub, K)`)
- 암호문: `C = C2 || C1 = E(Kpub, K) || E(K, P)`

#### 복호화

##### 분할

- 암호문: `C = C2 || C1 = E(Kpub, K) || E(K, P)`을 분할
  - `C1 = E(K, P)`: 대칭 키(K)로 암호화된 암호문
  - `C2 = E(Kpub, K)`: 수신자의 공개 키(Kpub)로 암호화된 세션 키

##### 세션 키 복호화

- `C2 = E(Kpub, K)` 복호화
- 수신자의 개인 키(Kpri)가 필요
  - 개인 키를 가지고 있는 사람이 아니면 세션 키를 복호화 할 수 없다
- `K = D(Kpri, C2)`: 수신자의 개인 키로 복호화된 세션 키는 메시지 복호화 키로 이용

##### 메시지 복호화

`P = D(K, C1)`

### 강한 하이브리드 암호 시스템

- 하이브리드 암호 시스템의 구성 요소
  - 의사난수 생성기
  - 대칭 암호
  - 공개 키 암호
- 각각의 기술 요소의 강도
- 강도의 밸런스도 중요

#### 의사난수 생성기

- 세션 키 생성에 사용
- 세션 키 중 일부 비트라도 추측되지 않도록 주의

#### 대칭 암호

- 메시지 암호화에 사용
- 강한 대칭 암호 알고리즘을 사용
- 충분히 길이가 긴 키 사용
- 적절한 블록 암호 모드 사용

#### 공개키 암호

- 세션 키 암호화에 사용
- 강한 공개 키 암호 알고리즘 사용
- 충분히 길이가 긴 키 사용

#### 키 길이의 밸런스

- 대칭 암호와 공개 키 암호의 키 길이는 양쪽이 같은 정도의 강도가 되도록 길이의 균형을 맞춤
- 장기간의 운용을 고려한다면 대칭 암호보다도 공개 키 암호 쪽을 강하게

### 암호 기술의 조합

- 하이브리드 암호 시스템: 대칭 암호와 공개 키 암호를 조합해서 양쪽의 장점을 살리는 시스템을 구축
- 블록 암호 모드: 고정 키 길이밖에 암호화할 수 없는 블록 암호를 조합해서 보다 긴 평문을 암호화
- 트리플 DES: DES를 3개 조합해서 DES보다도 긴 키 길이를 갖는 대칭 암호
- 디지털 서명: 일방향 해시 함수와 공개 키 암호를 조합
- 인증서: 공개 키와 디지털 서명을 조합
- 메시지 인증 코드: 일방향 해시 함수와 키를 조합, 대칭 암호로부터 생성
- 의사난수 생성기: 대칭 암호, 일방향 해시 함수, 공개 키 암호

#### 기타

- 전자 투표
- 디지털 캐시
- 블라인드 서명
  - 내용을 모르고 서명
- 영 지식 증명
  - 상대에게 정보를 건네지 않고 자신이 그 정보를 가지고 있다는 사실만을 증명해 보이는 방법

---

## 일방향 해시 함수

### 일방향 해시 함수

#### 파일의 진위

- 어제와 오늘의 파일이 같은지 조사 필요
- 무결성: 파일이 변경되지 않았다
  - 안전한 장소에 저장 후 어제 파일과 비교, 이 때 전체가 아닌 작은 지문 같은 값과 비교하면 편리

#### 일방향 해시 함수란

- 파일의 지문 채취 기술이다
- 입력과 출력이 각각 1개씩 있고 입력은 메시지, 출력은 해시 값

##### 일정한 크기 출력

- 해시 값 길이는 메시지 길이와 관계가 없어야 함
- ex) SHA-1 출력 항상 160비트

#### 일방향 해시 함수 성질

- 임의의 길이 메시지로부터 고정 길이 해시 값 계산
- 해시 값 고속 계산 가능
- 메시지가 다르면 해시 값도 다르다
- 일방향성을 가짐

##### 충돌

- 2개의 다른 메시지가 같은 해시 값 가지는 것
- 약한 충돌 내성: 메시지의 해시 값이 주어졌을 때 그 `해시 값과 같은 해시 값 찾는 다른 메시지 찾는 것`이 매우 어려운 것
- 강한 충돌 내성: 해시 값이 `일치할 것 같은 다른 2개 메시지를 발견`하는 것이 매우 어려운 것

#### 관련 용어

- 메시지 다이제스트 함수, 메시지 요약 함수, 암호적 해시 함수 등으로도 불리기도 한다
- 메시지는 프리 이미지로 불리기도 한다
- 해시 값은 메시지 다이제스트, 핑거프린트라고 불리기도 한다
- 무결성은 완전성, 보전성이라고 불리기도 한다

### 일방향 해시 함수 응용의 예

- 소프트웨어 변경 검출
- 패스워드를 기초로한 암호화
- 메시지 인증코드
  - 송신자와 수신자만이 공유하고 있는 키와 메시지를 혼합해 그 해시 값을 계산한 것
  - SSL/TLS에서도 이용 됨
- 디지털 서명
  - 날인 행위
  - 메시지 전체에 하지 않음, 메시지 해시 값을 구하고 그 해시 값에 디지털 서명 행함
- 의사난수 생성기: 예측 불가능성 보증 위해
- 일회용 패스워드: 정당한 클라이언트인지 아닌지 서버가 인증 시

### 일방향 해시 함수의 예

#### MD4, MD5

- MD4: 불안전
- MD5: 사용 권장 안 함

#### SHA-1, SHA-256, SHA-384, SHA-512

- SHA-1: 160비트의 해시 값
- SHA-256: 256 비트 해시 값, 메시지 길이 상한 2의 64승 비트 미만
- SHA-384: 384 비트 해시 값, 메시지 길이 상한 2의 128승 비트 미만
- SHA-512: 512 비트 해시 값, 메시지 길이 상한 2의 128승 비트 미만

#### RIPEMD-160

- 160비트 해시 값
- 비트코인 사용
- 별도 버전 -128, -256, -320 존재

#### SHA-3

- SHA-1의 강한 충돌 내성이 침해되어서 새롭게 선정함, AES처럼 경쟁 방식
- KECCAK을 표준으로 선정

### 일방향 해시 함수 SHA-512

- 입력: 최대 2의 128승 비트 이하 메시지
- 출력: 512 비트 메시지 다이제스트
- 입력 데이터는 길이 1024 비트 블록으로 처리

#### 단계

- 패딩 비트 붙이기: 여분 데이터 부가하여 길이가 `896 (mod 1024)`가 되도록 만든다
- 길이 붙이기: 128비트 블록 K를 메시지에 추가, 총 길이는 N \* 1024 비트
- MD버퍼 초기화: 512-비트 사용
- 1024 - 비트(128 - 워드)블록 메시지 처리: 각 라운드가 80 라운드로 구성, 각 라운드에서 512-비트 버퍼 값 이용
- 출력: N개의 1024-비트 블록을 모두 처리하면 N 번째 단계에서 512-비트 메시지 다이제스트가 출력

#### SHA-512 안정성

- 2의 256승 번 연산을 수행해야 동일한 메시지 다이제스트를 찾을 수 있다고 함
- 주어진 다이제스트와 같은 메시지 찾는 난이도는 2의 512승 번이기에 매우 안전

### SHA-3 선정 과정

- KECCAK 알고리즘이 결정

#### 선정 과정

- 경쟁 방식에 의한 표준화

#### 최종 후보와 SHA-3의 결정

- KECCAK 선정 이유
  - SHA-2와 전혀 다름
  - 구성 투명하여 구조 해석 쉬움
  - 다양한 디바이스에서 구동, 조합 형태 양호
  - 하드웨어 내장 시 높은 성능
  - 보안성 비교적 높음

### KECCAK

- 해시 값으로 임의 비트열 생성
- SHA3-224, SHA3-256, SHA3-384, SHA3-512 4 종류가 SHA-3
- 입력되는 데이터 제한 없음

#### 스펀지 구조

- 입력되는 메시지에 패딩을 시행한 후 흡수 단계와 추출 단계라는 두 개의 상태를 통해서 해시 값 출력

##### 흡수 단계

- 패딩된 입력 메시지를 r 비트 단위 입력 블록 분할
- 내부 상태의 r 비트와 입력 블록 1의 XOR을 구하고 그것을 함수 f에 입력
- 다음 함수 f의 출력 r 비트와 입력 블록 2의 XOR하고 그것을 다시 한 번 함수 f에 입력
- 이 과정 입력 블록 다 할때 까지

##### 추출 단계

- 함수 f의 출력 중 r 비트를 출력 블록 n로 기술하고 출력 전체는 함수 f로 다시 입력
- n번 만큼 반복

#### 듀플렉스 구조

- 스펀지 구조 변형
- 입력과 출력 같은 속도로 진행
- 해시 값 구하는 용도만이 아닌 의사난수 생성기, 스트림 암호, 인증이 포함된 암호 등 암호학자 도구상자 들어있는 대부분 기능 활용 가능

#### KECCAK 내부 상태

- 3차원 비트 배열
- 상태: x, y, z 모든 방향 고려한 3차원 내부 상태 전체, 비트는 하나를 뜻함

#### 함수 KECCAK-f[b]

- 내부 상태를 혼합하는 함수
- b를 폭이라 한다, (25, 50, 100, 200, 400, 800, 1600 총 7 종류)
  - SHA-3에서는 b = 1600 사용
  - SHA-3 내부 상태 `b = 5 x 5 x 64 = 1600 비트`
- 세타, 로우, 파이, 카이 아이오타라는 5개 단계를 1라운드라고 할 때 12 + 2아이오타 라운드를 반복
- SHA-3 사용 `KECCAK-f[1600]`의 경우 라운드 24
- 단계
  - 세타: 위치 이동시킨 컬럼 2개 5비트를 XOR, 그 결과를 목적 비트와 XOR 처리 후 목적 비트를 대체
  - 로우: z방향 비트 이동
  - 파이: 비트 이동을 레인 전체에 대해 수행
  - 카이: 논리회로 NOT과 AND 연산 활용
  - 아이오타
    - 라운드 정수라고 불리는 정수와 단계 전체 비트를 XOR, 내부 상태 비대칭성 위해 수행

#### KECCAK에 대한 공격

- MD 구조와 다른 스펀지 구조여서 현재까지 알려진 것 없다

### 일방향 해시 함수에 대한 공격

- 전사 공격: 약한 충돌 내성 깨는 공격, 문서 의미가 아닌 동일한 내용 다른 형태 표현 등으로 같은 해시 값 발견할 때 까지 작성
- 생일 공격: 강한 충돌 내성 깨고자 하는 내용, N명 중 적어도 2명 생일 일치할 확률이 1/2 이상이 되려면 23명
  - N의 크기를 크게 해야

### 일방향 해시 함수 사용 가이드

- SHA-2는 SHA-1 공격방법 대처해서 안전
- SHA-3 안전

---

## 메시지 인증 코드

### 메시지 인증 코드

- MAC, 무결성을 확인하고 메시지에 대한 인증 위한 코드
- 입력: 메시지, 공유하는 키
- 출력: 고정 비트 길이의 코드
- 메시지 인증: 메시지가 올바른 송신자로부터 온 것이다라는 성질
- 메시지인증 코드는 키에 의존하는 일방향 해시 함수다
- 키 배송 문제가 여전해서 앞서 말한 해결 방법으로 해결해야

#### 메시지 인증 코드 적용 순서

- 송수신자 사전에 키를 공유
- 송신자 메시지 작성, MAC 값 계산
- 송신자는 수신자에게 메시지와 MAC값 전송
- 수신자 수신한 메시지를 기초로 MAC 계산
- 송신자로부터 수신한 MAC, 자신이 계산한 MAC 계산 비교

### 메시지 인증 코드 이용 예

- SWIFT: 국제 은행간 통신협회, 은행과 은행은 SWIFT 통함
- IPsec: IP에 보안 기능 첨가, 통신 내용 인증과 무결성 위해 메시지 인증 코드 이용
- SSL/TLS: 웹 통신 프로토콜, 통신 내용 인증과 무결성 확인 위함

### 메시지 인증 코드 실현 방법

- 일방향 해시 함수: HMAC
- 블록 암호: 트리플 DES나 AES 이용
- 그 밖
  - 스트림 암호
  - 공개 키 암호

### 인증 암호

- 대칭 암호와 메시지 인증 코드를 조합해 기밀성, 무결성, 인증을 동시 충족함

#### GCM와 GMAC

##### GCM

- 인증 모드 일종
- CTR 모드 이용하여 덧셈, 곱셈 반복하는 해시 함수
- 1씩 늘어가는 숫자 암호화로 각 블록 병렬 처리로 실행속도 높임

##### GMAC

GCM을 메시지 인증 코드 전용으로 사용

### HMAC

- 일방향 해시 함수 이용하여 메시지 인증 코드 구성하는 방법
- 새 표준인 SHA-3 KECCAK 이용해 HMAC 작성 가능
- 순서
  - 키에 대한 패딩
  - 패딩한 키와 ipad의 XOR
  - 메시지 결합
  - 해시 값 계산
  - 패딩한 키와 opad의 XOR
  - 해시 값과 결합
  - 해시 값 계산

### 메시지 인증 코드에 대한 공격

#### 재전송 공격

보존해 둔 정당한 MAC 값 반복 송신

##### 방어 방법

- 순서 번호
- 타임스탬프
- 비표: 일회용 랜덤 값

#### 키 추측 공격

- 전사 공격, 생일 공격
- MAC 값만 획득한 공격자가 이를 추측 못하도록 해시 함수의 일방향성과 충돌내성, 의사난수생성기 이용해야

### 메시지 인증코드로 해결 불가한 문제

- 제 3자에게 증명: 키를 제 3자에게 말해줘야하고 모두 키를 가져서 누가 작성했는지 증명 불가
- 부인 방지: 송신자가 전송 자체를 부정하면 이 사실 제 3자에게 증명 분가

---

## 디지털 서명

### 디지털 서명

- 공개키 암호방식을 이용한 전자서명의 한 종류
- 전자서명에 작성자로 기재된 자가 그 전자문서를 작성하였다는 사실과 작성내용이 송.수신과정에서 위조.변조되지 않았다는 사실을 증면한다
- 부인 방지

##### 메시지 인증 코드 한계

- 부인 방지 불가

##### 디지털 서명 이용 해결

- 송신자가 사용하는 키는 송신자만 아는 키
- 송신자는 메시지 송신 시 그 개인적인 키로 서명
- 수신자는 송신자의 키와 다른 키 써서 서명 검출

#### 서명 작성과 검증

- 작성: 서명용 키, 검증용 키가 나뉘어져 검증용 키로 서명 불가
- 검증: 서명용 키는 서명자만 가지고 있으나 검증용 키는 검증하는 사람 모두가 가질 수 있다

#### 공개 키 암호와 디지털 서명

- 공개 키 암호를 역으로 이용하여 실현
- 메시지를 개인 키로 암호화 = 서명 작성
- 암호문을 공개 키로 복호화 = 서명 검증

### 디지털 서명 방법

#### 직접

- 송신자 자신의 개인 키로 메시지 암호화
- 메시지와 서명을 수신자에게 송신
- 수신자는 수신한 서명을 송신자 공개 키로 복호화
- 수신자는 서명을 복호화해 얻어진 메시지와 직접 수신한 메시지를 비교

#### 해시 값에

- 송신자는 일방향 해시 함수로 메시지 해시 값 계산
- 송신자의 개인 키로 해시 값 암호화
- 송신자는 메시지와 서명 수신자에게 송신
- 수신자는 받은 서명을 송신자의 공개 키로 복호화
- 수신자는 얻어진 해시 값과 송신자로부터 직접 수신한 메시지의 해시 값 비교

### 디지털 서명 활용 예

- 보안 공지
- 소프트웨어 다운로드: 사용자는 다운 후 서명 검증
- 공개 키 인증서
  - 공개 키를 메시지로 간주하고 그것에 디지털 서명을 한 것
  - 공개 키에 디지털 서명을 붙인 것
- SSL/TLS: 서버가 올바른 것이라는 것을 인증 위해 서버 인증서 이용, 서버 공개 키에 디지털 서명한 것

### RSA에 의한 디지털 서명

#### 작성

- `서명 = 메시지의 D승 mod N`
- D와 N은 개인 키

#### 검증

- `서명으로부터 얻어진 메시지 = 서명의 E승 mod N`
- E와 N은 서명자의 공개 키

### 기타 디지털 서명

- ElGamal: 이산대수 구하기 어렵다는 것 이용
- DSA: ElGamal 변종으로 디지털 서명에만 이용
- ECDSA: 타원곡선 암호(ECC)를 이용
- Rabin: 평방근 구하기 곤란하다는 것 이용

### 디지털 서명에 대한 공격

#### 중간자 공격

- 중간자 공격 막으려면 입수한 공개 키가 정확한 상대의 것인지 아닌지 확인 필요
- 핑거 프린트
  - 공개 키를 취급하는 소프트웨어에서 공개 키의 해시 값 표현하는 수단

#### 일방향 해시 함수에 대한 공격

- 충돌내성이 없는 해시 값이 생길 수 있다면 공격 가능

#### 디지털 서명을 사용한 공개 키 암호 공격

- 모르는 메시지는 디지털 서명 말아야

#### 잠재적 위조

- 개인 키가 없는 공격자가 의미 있는 메시지를 만들고 그에 대한 바른 디지털 서명 만들 수 있다면 디지털 서명은 안전하지 않다

##### RSA에서

- 복호화하는 디지털 서명 알고리즘에서 잠저잭 위조 가능
- 대처법: RSA-PSS
  - 메시지가 아닌 메시지의 해시 값에 서명, 솔트를 더함

#### 기타 공격

- 공개 키 암호에 대한 공격은 대부분 디지털 서명에 대한 공격으로서도 사용 가능
  - 개인 키 전사 공격
  - RSA의 N 소인수분해

### 디지털 서명으로 해결 불가한 문제

- 조작되지 않은 공개 키를 거짓 행세하고 있지 않은 송신자로부터 받아야
- 인증서: 바른 공개 키를 입수하기 위해 고안된 것

---

## 대칭 & 공개 키 암호 & 메시지 인증코드와 디지털 서명 비교

|              | 대칭 암호        | 공개 키 암호                             |
| ------------ | ---------------- | ---------------------------------------- |
| 송신자       | 공유 키로 암호화 | 공개 키로 암호화                         |
| 수신자       | 공유 키로 복호화 | 개인 키로 복호화                         |
| 키 배송 문제 | 발생한다         | 발생하지만, 공개 키의 인증이 별도로 필요 |
| 기밀성       | O                | O                                        |

|              | 메시지 인증 코드        | 디지털 서명                              |
| ------------ | ----------------------- | ---------------------------------------- |
| 송신자       | 공유 키로 MAC 값을 계산 | 개인 키로 서명을 작성                    |
| 수신자       | 공유 키로 MAC 값을 계산 | 공개 키로 서명을 검증                    |
| 키 배송 문제 | 발생한다                | 발생하지만, 공개 키의 인증이 별도로 필요 |
| 무결성       | O                       | O                                        |
| 인증         | O(통신 상대에 대해서만) | O(제 3자에 대해서도)                     |
| 부인방지     | X                       | O                                        |

---

## 인증서

### 인증서란 무엇

- 공개 키 인증서
  - 이름이나 소속, 메일 주소 등의 개인 정보
  - 당사자의 공개 키가 기재
  - 인증기관의 개인 키로 디지털 서명

### 인증서 활용 시나리오

- 수신자가 키 쌍 작성
- 수신자는 인증기관에 자신의 공개 키 등록
- 인증기관은 수신자의 공개 키에 인증기관의 개인 키로 디지털 서명을 해 인증서 작성
- 송신자는 인증기관의 디지털 서명이 된 수신자의 공개 키 입수
- 송신자는 인증기관의 공개 키 이용해서 디지털 서명 검증하고 수신자의 공개 키가 맞다는 것 확인
- 송신자는 수신자의 공개 키로 메시지 암호화해 수신자에게 송신
- 수신자는 암호문을 자신의 개인 키로 복호화해서 송신자의 메시지 읽음

### 공인 인증서

#### 종류

- 범용
  - 모든 분야
  - 소정의 수수료
- 용도 제한
  - 은행, 보험, 신용카드, 정부 민원 등에서만
  - 무료

#### 표준 규격

- X.509
- 공개 키 인증서와 인증 알고리즘 표준 공개 키 기반(PKI)의 ITU-T 표준
- 가장 널리 사용한다
- 인증서 생성, 교환 수행 시 사용

### 공개 키 기반 구조 (PKI)

#### 공개 키 기반

- 공개 키 효과적 운용 위한 규격이나 선택 사양 총칭
  - PKCS, RFC, X.509, API 사양서

#### 구성요소

##### 이용자

- PKI 이용자 및 공개 키 등록 원하는 자
- 하는 일
  - 키 쌍 작성(인증 기관이 할 수도)
  - 인증기관에 공개 키 등록 및 인증서 발행 받음, 무효로 할 수도
  - 수신한 암호문 복호화 및 메시지에 디지털 서명

##### 인증 기관

- 인증서 발행
- 키 쌍 작성(이용자가 할 수도)
- 공개 키 등록 시 본인 인증
- 인증서 작성 및 발행, 폐지
- 등록 기관: 인증 기관의 일 중 공개 키의 등록과 본인에 대한 인증 대행 기관

##### 저장소

- 인증서 보관, PKI 이용자가 인증서 입수 가능

#### 인증기관 역할

- 키 쌍 생성
- 인증서 등록: 인증 기관의 개인 키 이용해 디지털 서명함 (X.509)
- 인증서 폐지와 CRL(인증서 폐지목록) 작성 및 조사해서 인증서 유효성 확인

#### 계층 구조 갖는 인증서

- 루트 CA: 최상위 인증 기관
- 셀프 서명: 자신의 공개 키에 대해 자신의 개인 키로 서명

### 인증서에 대한 공격

#### 공개 키 등록 이전 공격

- 인증기관이 디지털 서명 수행 이전, 공격자가 자신의 공개 키로 바꿔 치기

#### 닮은 사람 등록 공격

- 오인하기 쉬운 사용자 정보 사용

#### 인증 기관 개인 키 훔치기

- 인증 기관의 개인 키 도난 시 인증기관은 자신의 키가 도난당했다는 것을 CRL 사용해서 이용자에게 통지해야

#### 공격자 자신이 인증기관이 되는 경우

- 인증서 자유 발행하게 됨
- 인증기관 신뢰 불가하면 인증서가 바르더라도 그 공개키 사용해서는 안 됨

### CRL 허점 이용

- CRL 도착 전 빠른 공격

### 슈퍼피시

- 슈퍼피시라는 애드웨어가 가 보안 상 문제 일으킴
- 루트 인증서 인스톨하여 웹사이트와 웹 브라우저 사이 들어간 후 웹사이트 인증서 바꿔치기하여 웹브라우저에 제시
- 중간자 공격

---

## 키

### 키

#### 키는 대단히 큰 수

- 수 자체라기보다 키 공간
- 키의 비트가 결정

#### 암호별 키 길이

- DES: 56
- 3DES
  - DES-EDE2: 112
  - DES-EDE3: 168
- AES: 128, 192, 256
- RSA: 1024, 2046, 4092 등

#### 키는 평문과 동일한 가치

- 키가 넘어가면 평문 넘어가는 것과 같음

#### 암호 알고리즘과 키

- 검증된 알고리즘 사용
- 키를 비밀로 해서 기밀성 지켜져야

### 다양한 키

- 대칭 암호: 키는 송신자와 수신자만 공유, 양측 비밀 유지
- 공개 키 암호
  - 암호화와 복호화에서 다른 키 사용
  - 개인키를 비밀로 유지
- 메시지 인증코드 키: 송신자와 수신자가 공통의 키를 사용해 인증 수행
- 디지털 서명 키: 서명 작성과 검증에 다른 키 사용
- 기밀성 위한 키: 대칭 암호, 공개 키 암호에서 사용, 복호화 키를 모르면 복호 불가
- 인증 위한 키: 메시지 인증코드나 디지털 서명에서 사용, 키를 모르면 데이터 변경이나 위장 불가
- 세션 키: 통신 때 마다 한번만 사용 되는 키
- 마스터 키: 반복 적 사용 키

### 콘텐츠 암호화 키와 암호화 키

- CEK: 정보가 암호화 대상
- KEK: 키가 암호화 대상

### 키 관리

#### 키 생성

- 난수 이용: 추측 어렵게 하기에 적합
- 패스워드 이용: 패스워드를 일방향 해시 함수에 입력해 해시 값 이용이 주
  - 솔트: 솔트라 불리는 난수 부가해 일방향 해시 함수에 입력 후 출력을 키로 사용, 사전 공격 막기 위함

#### 키 배송

- 키 사전 공유하는 방법, 키 배포 센터, 공개 키 암호, 디피 헬만 키 교환

#### 키 갱신

- 공통 키 사용하여 통신 중 정기적 키 교환
- 송수신자가 동시 같은 방법으로 교환해야
- 현재 키의 해시 값을 다음 키로 사용
- 키 노출 시 과거 통신 복호화 막을 수 있음

#### 키 보존

- 키 반복 사용 시 키 저장 문제 고려
- 기억하거나, 암호화

##### KEK

- 키 암호화하는 키, 다수의 키를 한 개의 키로 암호화해 보관

#### 키 폐기

- 불필요하면 삭제해야 복호화, 인증 등을 막을 수 있다

### 디피-헬만 키 교환

#### 디피 헬만 키 교환

- 타인에게 알려져도 상관 없는 정보를 두 사람이 교환하는 것만으로 공통의 비밀 값을 만들어내는 방법
- IPsec에서는 디피 헬만 키 교환을 개량한 방법 사용

#### 절차

- 송신자는 수신자에게 2개의 소수 P와 원시근 G 송신
- 송신자는 난수 A를 준비
- 수신자는 난수 B를 준비
- 송신자는 수신자에게 `G의 A승 mod P`라는 수 송신
- 수신자는 송신자에게 `G의 B승 mod P`라는 수 송신
- 송신자는 수신자가 보낸 수를 A 제급 해서 mod P 계산
- 수신자는 송신자가 보낸 수를 B 제곱 해서 mod P 계산

#### 원시근의 의미

- mod P 연산할 때 P가 13이라면 0부터 13이 쓰여진 둥근 시계가 만들어진다
- mod P 연산 했을 때 0~12까지 같은 값이 나오지 않는 수

### 타원 곡선 디피 헬만 키 교환

- 이산대수 문제를 타원곡선 상의 이산대수 문제로 대체한 키 교환 알고리즘
- 디피 헬만 키 교환보다 짧은 키 길이로 높은 보안성 실현

### PBE

- 패스워드를 기초로 해서 만든 키로 암호화 수행하는 방법
- RSA 사의 PKCS #5 규격으로 규정된 PBE는 Java의 java.crypto 패키지 등에 내장
- 암호 소프트웨어 PGP에서 키 보존
- 절차 중 핵심
  - KEK는 패스워드로 하여 머릿속에 보존, 솔트와 암호화한 CEK와 함께 보존

#### 암호화

- KEK 생성: 의사난수 생성기로 솔트 생성 후 입력한 패스워드를 일방향 해시함수에 입력
- 세션 키 생성과 암호화
  - 의사난수 생성기 사용하여 세션키 생성
  - KEK 사용하여 암호화하고 솔트와 함께 안전한 장소 보존
  - 세션 키 암호화 끝나고 KEK는 폐기
- 메시지 암호화
  - 세션 키를 사용해 메시지 암호화
    - 솔트, KEK로 암호화된 세션 키, 세션 키로 암호화된 메시지
  - 솔트와 KEK로 암호화된 세션 키는 안전한 장소에 보관

#### 복호화

- KEK 복원: 보존해둔 솔트와 기억한 패스워드를 일방향 해시 함수에 순서대로 입력
- 세션 키 복호화: 보존해둔 KEK로 암호화된 세션 키를 가지고 와서 KEK를 사용해 복호화
- 메시지 복호화: 복호화한 세션 키를 사용해 암호화된 메시지를 복호화

#### 솔트 역할

- 의사 난수 생성기로 만들어지는 랜덤한 수로 KEK를 만들 때 패스워드와 함께 일방향 해시 함수 입력
  - 사전 공격 막기 위해

#### 패스워드 역할

- 충분한 비트 수를 갖는 패스워드는 기억 불가
- PBE에서는 KEK로 CEK 암호화, KEK는 비교적 약하다
- PBE를 이용하려면 솔트와 암호화한 CEK를 물리적으로 지키는 방법을 병행해야

#### 스트레칭에 의한 PBE 개선

- 일방향 해시 함수 적용 회수를 증가 시켜라

### 안전한 패스워드를 만들려면

- 자신 만이 아는 정보
- 복수의 패스워드를 나누어 쓰기 (하나 패스워드 복수 사용 금지)
- 메모를 유효하게 사용 (일부만 메모)
- 패스워드의 한계를 알자
  - 48비트 정도에 지나지 않음, 전사 공격이 가능하다
- 패스워드 생성/관리 툴 사용
  - 수 많은 서비스 사용 시 다수의 ID와 패스워드 필요
  - 생성/관리 툴 사용하는 것이 바람직
    - 난수 생성 후 브라우저 연계, 툴이 신뢰할 수 있어야함
